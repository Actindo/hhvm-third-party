/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/Thrift.h>
#include <thrift/lib/cpp2/protocol/Protocol.h>
#include <thrift/lib/cpp/TApplicationException.h>
#include <folly/io/IOBuf.h>
#include <folly/io/Cursor.h>
#include <boost/operators.hpp>




namespace facebook { namespace memcache { namespace cpp2 {

class McGetRequest;
class McGetReply;
class McSetRequest;
class McSetReply;
class McDeleteRequest;
class McDeleteReply;
class McLeaseGetRequest;
class McLeaseGetReply;
class McLeaseSetRequest;
class McLeaseSetReply;
class McAddRequest;
class McAddReply;
class McReplaceRequest;
class McReplaceReply;
class McGetsRequest;
class McGetsReply;
class McCasRequest;
class McCasReply;
class McIncrRequest;
class McIncrReply;
class McDecrRequest;
class McDecrReply;
class McMetagetRequest;
class McMetagetReply;
class McVersionRequest;
class McVersionReply;
class McAppendRequest;
class McAppendReply;
class McPrependRequest;
class McPrependReply;
class McTouchRequest;
class McTouchReply;
class McStatsRequest;
class McStatsReply;
class McShutdownRequest;
class McShutdownReply;
class McQuitRequest;
class McQuitReply;
class McExecRequest;
class McExecReply;
class McFlushReRequest;
class McFlushReReply;
class McFlushAllRequest;
class McFlushAllReply;
typedef folly::IOBuf IOBuf;

class McGetRequest : private boost::totally_ordered<McGetRequest> {
 public:

  McGetRequest() :
      flags(0) {}
  // FragileConstructor for use in initialization lists only

  McGetRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg, int64_t flags__arg) :
      key(std::move(key__arg)),
      flags(std::move(flags__arg)) {
    __isset.key = true;
    __isset.flags = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McGetRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McGetRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    key = arg.move();
    __isset.key = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McGetRequest(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McGetRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    flags = arg.move();
    __isset.flags = true;
  }

  McGetRequest(McGetRequest&&) = default;

  McGetRequest(const McGetRequest&) = default;

  McGetRequest& operator=(McGetRequest&&) = default;

  McGetRequest& operator=(const McGetRequest&) = default;
  void __clear();

  virtual ~McGetRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;
  int64_t flags;

  struct __isset {
    void __clear() {
      key = false;
      flags = false;
    }

    bool key = false;
    bool flags = false;
  } __isset;
  bool operator==(const McGetRequest& rhs) const;
  bool operator < (const McGetRequest& rhs) const;

  const  ::facebook::memcache::cpp2::IOBuf& get_key() const& {
    return key;
  }

   ::facebook::memcache::cpp2::IOBuf get_key() && {
    return std::move(key);
  }

  template <typename T_McGetRequest_key_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_key(T_McGetRequest_key_struct_setter&& key_) {
    key = std::forward<T_McGetRequest_key_struct_setter>(key_);
    __isset.key = true;
    return key;
  }

  const int64_t* get_flags() const& {
    return __isset.flags ? std::addressof(flags) : nullptr;
  }

  int64_t* get_flags() & {
    return __isset.flags ? std::addressof(flags) : nullptr;
  }
  int64_t* get_flags() && = delete;

  int64_t& set_flags(int64_t flags_) {
    flags = flags_;
    __isset.flags = true;
    return flags;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McGetRequest& a, McGetRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McGetRequest>::clear( ::facebook::memcache::cpp2::McGetRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McGetRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McGetRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McGetRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McGetRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McGetRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McGetReply : private boost::totally_ordered<McGetReply> {
 public:

  McGetReply() :
      result(0),
      flags(0),
      appSpecificErrorCode(0) {}
  // FragileConstructor for use in initialization lists only

  McGetReply(apache::thrift::FragileConstructor, int16_t result__arg,  ::facebook::memcache::cpp2::IOBuf value__arg, int64_t flags__arg, std::string message__arg, int16_t appSpecificErrorCode__arg) :
      result(std::move(result__arg)),
      value(std::move(value__arg)),
      flags(std::move(flags__arg)),
      message(std::move(message__arg)),
      appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
    __isset.result = true;
    __isset.value = true;
    __isset.flags = true;
    __isset.message = true;
    __isset.appSpecificErrorCode = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McGetReply(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McGetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    result = arg.move();
    __isset.result = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McGetReply(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McGetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    value = arg.move();
    __isset.value = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McGetReply(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McGetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    flags = arg.move();
    __isset.flags = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McGetReply(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McGetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    message = arg.move();
    __isset.message = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McGetReply(::apache::thrift::detail::argument_wrapper<5, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McGetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    appSpecificErrorCode = arg.move();
    __isset.appSpecificErrorCode = true;
  }

  McGetReply(McGetReply&&) = default;

  McGetReply(const McGetReply&) = default;

  McGetReply& operator=(McGetReply&&) = default;

  McGetReply& operator=(const McGetReply&) = default;
  void __clear();

  virtual ~McGetReply() throw() {}

  int16_t result;
   ::facebook::memcache::cpp2::IOBuf value;
  int64_t flags;
  std::string message;
  int16_t appSpecificErrorCode;

  struct __isset {
    void __clear() {
      result = false;
      value = false;
      flags = false;
      message = false;
      appSpecificErrorCode = false;
    }

    bool result = false;
    bool value = false;
    bool flags = false;
    bool message = false;
    bool appSpecificErrorCode = false;
  } __isset;
  bool operator==(const McGetReply& rhs) const;
  bool operator < (const McGetReply& rhs) const;

  int16_t get_result() const {
    return result;
  }

  int16_t& set_result(int16_t result_) {
    result = result_;
    __isset.result = true;
    return result;
  }

  const  ::facebook::memcache::cpp2::IOBuf* get_value() const& {
    return __isset.value ? std::addressof(value) : nullptr;
  }

   ::facebook::memcache::cpp2::IOBuf* get_value() & {
    return __isset.value ? std::addressof(value) : nullptr;
  }
   ::facebook::memcache::cpp2::IOBuf* get_value() && = delete;

  template <typename T_McGetReply_value_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_value(T_McGetReply_value_struct_setter&& value_) {
    value = std::forward<T_McGetReply_value_struct_setter>(value_);
    __isset.value = true;
    return value;
  }

  const int64_t* get_flags() const& {
    return __isset.flags ? std::addressof(flags) : nullptr;
  }

  int64_t* get_flags() & {
    return __isset.flags ? std::addressof(flags) : nullptr;
  }
  int64_t* get_flags() && = delete;

  int64_t& set_flags(int64_t flags_) {
    flags = flags_;
    __isset.flags = true;
    return flags;
  }

  const std::string* get_message() const& {
    return __isset.message ? std::addressof(message) : nullptr;
  }

  std::string* get_message() & {
    return __isset.message ? std::addressof(message) : nullptr;
  }
  std::string* get_message() && = delete;

  template <typename T_McGetReply_message_struct_setter>
  std::string& set_message(T_McGetReply_message_struct_setter&& message_) {
    message = std::forward<T_McGetReply_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  const int16_t* get_appSpecificErrorCode() const& {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }

  int16_t* get_appSpecificErrorCode() & {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }
  int16_t* get_appSpecificErrorCode() && = delete;

  int16_t& set_appSpecificErrorCode(int16_t appSpecificErrorCode_) {
    appSpecificErrorCode = appSpecificErrorCode_;
    __isset.appSpecificErrorCode = true;
    return appSpecificErrorCode;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McGetReply& a, McGetReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McGetReply>::clear( ::facebook::memcache::cpp2::McGetReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McGetReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McGetReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McGetReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McGetReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McGetReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McSetRequest : private boost::totally_ordered<McSetRequest> {
 public:

  McSetRequest() :
      exptime(0),
      flags(0) {}
  // FragileConstructor for use in initialization lists only

  McSetRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg, int32_t exptime__arg, int64_t flags__arg,  ::facebook::memcache::cpp2::IOBuf value__arg) :
      key(std::move(key__arg)),
      exptime(std::move(exptime__arg)),
      flags(std::move(flags__arg)),
      value(std::move(value__arg)) {
    __isset.key = true;
    __isset.exptime = true;
    __isset.flags = true;
    __isset.value = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McSetRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McSetRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    key = arg.move();
    __isset.key = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McSetRequest(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McSetRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    exptime = arg.move();
    __isset.exptime = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McSetRequest(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McSetRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    flags = arg.move();
    __isset.flags = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McSetRequest(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McSetRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    value = arg.move();
    __isset.value = true;
  }

  McSetRequest(McSetRequest&&) = default;

  McSetRequest(const McSetRequest&) = default;

  McSetRequest& operator=(McSetRequest&&) = default;

  McSetRequest& operator=(const McSetRequest&) = default;
  void __clear();

  virtual ~McSetRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;
  int32_t exptime;
  int64_t flags;
   ::facebook::memcache::cpp2::IOBuf value;

  struct __isset {
    void __clear() {
      key = false;
      exptime = false;
      flags = false;
      value = false;
    }

    bool key = false;
    bool exptime = false;
    bool flags = false;
    bool value = false;
  } __isset;
  bool operator==(const McSetRequest& rhs) const;
  bool operator < (const McSetRequest& rhs) const;

  const  ::facebook::memcache::cpp2::IOBuf& get_key() const& {
    return key;
  }

   ::facebook::memcache::cpp2::IOBuf get_key() && {
    return std::move(key);
  }

  template <typename T_McSetRequest_key_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_key(T_McSetRequest_key_struct_setter&& key_) {
    key = std::forward<T_McSetRequest_key_struct_setter>(key_);
    __isset.key = true;
    return key;
  }

  int32_t get_exptime() const {
    return exptime;
  }

  int32_t& set_exptime(int32_t exptime_) {
    exptime = exptime_;
    __isset.exptime = true;
    return exptime;
  }

  int64_t get_flags() const {
    return flags;
  }

  int64_t& set_flags(int64_t flags_) {
    flags = flags_;
    __isset.flags = true;
    return flags;
  }

  const  ::facebook::memcache::cpp2::IOBuf& get_value() const& {
    return value;
  }

   ::facebook::memcache::cpp2::IOBuf get_value() && {
    return std::move(value);
  }

  template <typename T_McSetRequest_value_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_value(T_McSetRequest_value_struct_setter&& value_) {
    value = std::forward<T_McSetRequest_value_struct_setter>(value_);
    __isset.value = true;
    return value;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McSetRequest& a, McSetRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McSetRequest>::clear( ::facebook::memcache::cpp2::McSetRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McSetRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McSetRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McSetRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McSetRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McSetRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McSetRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McSetRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McSetRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McSetRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McSetReply : private boost::totally_ordered<McSetReply> {
 public:

  McSetReply() :
      result(0),
      flags(0),
      appSpecificErrorCode(0) {}
  // FragileConstructor for use in initialization lists only

  McSetReply(apache::thrift::FragileConstructor, int16_t result__arg, int64_t flags__arg,  ::facebook::memcache::cpp2::IOBuf value__arg, std::string message__arg, int16_t appSpecificErrorCode__arg) :
      result(std::move(result__arg)),
      flags(std::move(flags__arg)),
      value(std::move(value__arg)),
      message(std::move(message__arg)),
      appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
    __isset.result = true;
    __isset.flags = true;
    __isset.value = true;
    __isset.message = true;
    __isset.appSpecificErrorCode = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McSetReply(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McSetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    result = arg.move();
    __isset.result = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McSetReply(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McSetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    flags = arg.move();
    __isset.flags = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McSetReply(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McSetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    value = arg.move();
    __isset.value = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McSetReply(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McSetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    message = arg.move();
    __isset.message = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McSetReply(::apache::thrift::detail::argument_wrapper<5, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McSetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    appSpecificErrorCode = arg.move();
    __isset.appSpecificErrorCode = true;
  }

  McSetReply(McSetReply&&) = default;

  McSetReply(const McSetReply&) = default;

  McSetReply& operator=(McSetReply&&) = default;

  McSetReply& operator=(const McSetReply&) = default;
  void __clear();

  virtual ~McSetReply() throw() {}

  int16_t result;
  int64_t flags;
   ::facebook::memcache::cpp2::IOBuf value;
  std::string message;
  int16_t appSpecificErrorCode;

  struct __isset {
    void __clear() {
      result = false;
      flags = false;
      value = false;
      message = false;
      appSpecificErrorCode = false;
    }

    bool result = false;
    bool flags = false;
    bool value = false;
    bool message = false;
    bool appSpecificErrorCode = false;
  } __isset;
  bool operator==(const McSetReply& rhs) const;
  bool operator < (const McSetReply& rhs) const;

  int16_t get_result() const {
    return result;
  }

  int16_t& set_result(int16_t result_) {
    result = result_;
    __isset.result = true;
    return result;
  }

  const int64_t* get_flags() const& {
    return __isset.flags ? std::addressof(flags) : nullptr;
  }

  int64_t* get_flags() & {
    return __isset.flags ? std::addressof(flags) : nullptr;
  }
  int64_t* get_flags() && = delete;

  int64_t& set_flags(int64_t flags_) {
    flags = flags_;
    __isset.flags = true;
    return flags;
  }

  const  ::facebook::memcache::cpp2::IOBuf* get_value() const& {
    return __isset.value ? std::addressof(value) : nullptr;
  }

   ::facebook::memcache::cpp2::IOBuf* get_value() & {
    return __isset.value ? std::addressof(value) : nullptr;
  }
   ::facebook::memcache::cpp2::IOBuf* get_value() && = delete;

  template <typename T_McSetReply_value_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_value(T_McSetReply_value_struct_setter&& value_) {
    value = std::forward<T_McSetReply_value_struct_setter>(value_);
    __isset.value = true;
    return value;
  }

  const std::string* get_message() const& {
    return __isset.message ? std::addressof(message) : nullptr;
  }

  std::string* get_message() & {
    return __isset.message ? std::addressof(message) : nullptr;
  }
  std::string* get_message() && = delete;

  template <typename T_McSetReply_message_struct_setter>
  std::string& set_message(T_McSetReply_message_struct_setter&& message_) {
    message = std::forward<T_McSetReply_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  const int16_t* get_appSpecificErrorCode() const& {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }

  int16_t* get_appSpecificErrorCode() & {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }
  int16_t* get_appSpecificErrorCode() && = delete;

  int16_t& set_appSpecificErrorCode(int16_t appSpecificErrorCode_) {
    appSpecificErrorCode = appSpecificErrorCode_;
    __isset.appSpecificErrorCode = true;
    return appSpecificErrorCode;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McSetReply& a, McSetReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McSetReply>::clear( ::facebook::memcache::cpp2::McSetReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McSetReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McSetReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McSetReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McSetReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McSetReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McSetReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McSetReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McSetReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McSetReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McDeleteRequest : private boost::totally_ordered<McDeleteRequest> {
 public:

  McDeleteRequest() :
      flags(0),
      exptime(0) {}
  // FragileConstructor for use in initialization lists only

  McDeleteRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg, int64_t flags__arg, int32_t exptime__arg,  ::facebook::memcache::cpp2::IOBuf value__arg) :
      key(std::move(key__arg)),
      flags(std::move(flags__arg)),
      exptime(std::move(exptime__arg)),
      value(std::move(value__arg)) {
    __isset.key = true;
    __isset.flags = true;
    __isset.exptime = true;
    __isset.value = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McDeleteRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McDeleteRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    key = arg.move();
    __isset.key = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McDeleteRequest(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McDeleteRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    flags = arg.move();
    __isset.flags = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McDeleteRequest(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McDeleteRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    exptime = arg.move();
    __isset.exptime = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McDeleteRequest(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McDeleteRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    value = arg.move();
    __isset.value = true;
  }

  McDeleteRequest(McDeleteRequest&&) = default;

  McDeleteRequest(const McDeleteRequest&) = default;

  McDeleteRequest& operator=(McDeleteRequest&&) = default;

  McDeleteRequest& operator=(const McDeleteRequest&) = default;
  void __clear();

  virtual ~McDeleteRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;
  int64_t flags;
  int32_t exptime;
   ::facebook::memcache::cpp2::IOBuf value;

  struct __isset {
    void __clear() {
      key = false;
      flags = false;
      exptime = false;
      value = false;
    }

    bool key = false;
    bool flags = false;
    bool exptime = false;
    bool value = false;
  } __isset;
  bool operator==(const McDeleteRequest& rhs) const;
  bool operator < (const McDeleteRequest& rhs) const;

  const  ::facebook::memcache::cpp2::IOBuf& get_key() const& {
    return key;
  }

   ::facebook::memcache::cpp2::IOBuf get_key() && {
    return std::move(key);
  }

  template <typename T_McDeleteRequest_key_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_key(T_McDeleteRequest_key_struct_setter&& key_) {
    key = std::forward<T_McDeleteRequest_key_struct_setter>(key_);
    __isset.key = true;
    return key;
  }

  const int64_t* get_flags() const& {
    return __isset.flags ? std::addressof(flags) : nullptr;
  }

  int64_t* get_flags() & {
    return __isset.flags ? std::addressof(flags) : nullptr;
  }
  int64_t* get_flags() && = delete;

  int64_t& set_flags(int64_t flags_) {
    flags = flags_;
    __isset.flags = true;
    return flags;
  }

  const int32_t* get_exptime() const& {
    return __isset.exptime ? std::addressof(exptime) : nullptr;
  }

  int32_t* get_exptime() & {
    return __isset.exptime ? std::addressof(exptime) : nullptr;
  }
  int32_t* get_exptime() && = delete;

  int32_t& set_exptime(int32_t exptime_) {
    exptime = exptime_;
    __isset.exptime = true;
    return exptime;
  }

  const  ::facebook::memcache::cpp2::IOBuf* get_value() const& {
    return __isset.value ? std::addressof(value) : nullptr;
  }

   ::facebook::memcache::cpp2::IOBuf* get_value() & {
    return __isset.value ? std::addressof(value) : nullptr;
  }
   ::facebook::memcache::cpp2::IOBuf* get_value() && = delete;

  template <typename T_McDeleteRequest_value_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_value(T_McDeleteRequest_value_struct_setter&& value_) {
    value = std::forward<T_McDeleteRequest_value_struct_setter>(value_);
    __isset.value = true;
    return value;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McDeleteRequest& a, McDeleteRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McDeleteRequest>::clear( ::facebook::memcache::cpp2::McDeleteRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McDeleteRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDeleteRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McDeleteRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDeleteRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McDeleteRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDeleteRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McDeleteRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDeleteRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McDeleteRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McDeleteReply : private boost::totally_ordered<McDeleteReply> {
 public:

  McDeleteReply() :
      result(0),
      flags(0),
      appSpecificErrorCode(0) {}
  // FragileConstructor for use in initialization lists only

  McDeleteReply(apache::thrift::FragileConstructor, int16_t result__arg, int64_t flags__arg,  ::facebook::memcache::cpp2::IOBuf value__arg, std::string message__arg, int16_t appSpecificErrorCode__arg) :
      result(std::move(result__arg)),
      flags(std::move(flags__arg)),
      value(std::move(value__arg)),
      message(std::move(message__arg)),
      appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
    __isset.result = true;
    __isset.flags = true;
    __isset.value = true;
    __isset.message = true;
    __isset.appSpecificErrorCode = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McDeleteReply(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McDeleteReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    result = arg.move();
    __isset.result = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McDeleteReply(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McDeleteReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    flags = arg.move();
    __isset.flags = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McDeleteReply(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McDeleteReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    value = arg.move();
    __isset.value = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McDeleteReply(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McDeleteReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    message = arg.move();
    __isset.message = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McDeleteReply(::apache::thrift::detail::argument_wrapper<5, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McDeleteReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    appSpecificErrorCode = arg.move();
    __isset.appSpecificErrorCode = true;
  }

  McDeleteReply(McDeleteReply&&) = default;

  McDeleteReply(const McDeleteReply&) = default;

  McDeleteReply& operator=(McDeleteReply&&) = default;

  McDeleteReply& operator=(const McDeleteReply&) = default;
  void __clear();

  virtual ~McDeleteReply() throw() {}

  int16_t result;
  int64_t flags;
   ::facebook::memcache::cpp2::IOBuf value;
  std::string message;
  int16_t appSpecificErrorCode;

  struct __isset {
    void __clear() {
      result = false;
      flags = false;
      value = false;
      message = false;
      appSpecificErrorCode = false;
    }

    bool result = false;
    bool flags = false;
    bool value = false;
    bool message = false;
    bool appSpecificErrorCode = false;
  } __isset;
  bool operator==(const McDeleteReply& rhs) const;
  bool operator < (const McDeleteReply& rhs) const;

  int16_t get_result() const {
    return result;
  }

  int16_t& set_result(int16_t result_) {
    result = result_;
    __isset.result = true;
    return result;
  }

  const int64_t* get_flags() const& {
    return __isset.flags ? std::addressof(flags) : nullptr;
  }

  int64_t* get_flags() & {
    return __isset.flags ? std::addressof(flags) : nullptr;
  }
  int64_t* get_flags() && = delete;

  int64_t& set_flags(int64_t flags_) {
    flags = flags_;
    __isset.flags = true;
    return flags;
  }

  const  ::facebook::memcache::cpp2::IOBuf* get_value() const& {
    return __isset.value ? std::addressof(value) : nullptr;
  }

   ::facebook::memcache::cpp2::IOBuf* get_value() & {
    return __isset.value ? std::addressof(value) : nullptr;
  }
   ::facebook::memcache::cpp2::IOBuf* get_value() && = delete;

  template <typename T_McDeleteReply_value_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_value(T_McDeleteReply_value_struct_setter&& value_) {
    value = std::forward<T_McDeleteReply_value_struct_setter>(value_);
    __isset.value = true;
    return value;
  }

  const std::string* get_message() const& {
    return __isset.message ? std::addressof(message) : nullptr;
  }

  std::string* get_message() & {
    return __isset.message ? std::addressof(message) : nullptr;
  }
  std::string* get_message() && = delete;

  template <typename T_McDeleteReply_message_struct_setter>
  std::string& set_message(T_McDeleteReply_message_struct_setter&& message_) {
    message = std::forward<T_McDeleteReply_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  const int16_t* get_appSpecificErrorCode() const& {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }

  int16_t* get_appSpecificErrorCode() & {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }
  int16_t* get_appSpecificErrorCode() && = delete;

  int16_t& set_appSpecificErrorCode(int16_t appSpecificErrorCode_) {
    appSpecificErrorCode = appSpecificErrorCode_;
    __isset.appSpecificErrorCode = true;
    return appSpecificErrorCode;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McDeleteReply& a, McDeleteReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McDeleteReply>::clear( ::facebook::memcache::cpp2::McDeleteReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McDeleteReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDeleteReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McDeleteReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDeleteReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McDeleteReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDeleteReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McDeleteReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDeleteReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McDeleteReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McLeaseGetRequest : private boost::totally_ordered<McLeaseGetRequest> {
 public:

  McLeaseGetRequest() {}
  // FragileConstructor for use in initialization lists only

  McLeaseGetRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg) :
      key(std::move(key__arg)) {
    __isset.key = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McLeaseGetRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McLeaseGetRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    key = arg.move();
    __isset.key = true;
  }

  McLeaseGetRequest(McLeaseGetRequest&&) = default;

  McLeaseGetRequest(const McLeaseGetRequest&) = default;

  McLeaseGetRequest& operator=(McLeaseGetRequest&&) = default;

  McLeaseGetRequest& operator=(const McLeaseGetRequest&) = default;
  void __clear();

  virtual ~McLeaseGetRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;

  struct __isset {
    void __clear() {
      key = false;
    }

    bool key = false;
  } __isset;
  bool operator==(const McLeaseGetRequest& rhs) const;
  bool operator < (const McLeaseGetRequest& rhs) const;

  const  ::facebook::memcache::cpp2::IOBuf& get_key() const& {
    return key;
  }

   ::facebook::memcache::cpp2::IOBuf get_key() && {
    return std::move(key);
  }

  template <typename T_McLeaseGetRequest_key_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_key(T_McLeaseGetRequest_key_struct_setter&& key_) {
    key = std::forward<T_McLeaseGetRequest_key_struct_setter>(key_);
    __isset.key = true;
    return key;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McLeaseGetRequest& a, McLeaseGetRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McLeaseGetRequest>::clear( ::facebook::memcache::cpp2::McLeaseGetRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McLeaseGetRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseGetRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McLeaseGetRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseGetRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McLeaseGetRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseGetRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McLeaseGetRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseGetRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McLeaseGetRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McLeaseGetReply : private boost::totally_ordered<McLeaseGetReply> {
 public:

  McLeaseGetReply() :
      result(0),
      leaseToken(0),
      flags(0),
      appSpecificErrorCode(0) {}
  // FragileConstructor for use in initialization lists only

  McLeaseGetReply(apache::thrift::FragileConstructor, int16_t result__arg, int64_t leaseToken__arg,  ::facebook::memcache::cpp2::IOBuf value__arg, int64_t flags__arg, std::string message__arg, int16_t appSpecificErrorCode__arg) :
      result(std::move(result__arg)),
      leaseToken(std::move(leaseToken__arg)),
      value(std::move(value__arg)),
      flags(std::move(flags__arg)),
      message(std::move(message__arg)),
      appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
    __isset.result = true;
    __isset.leaseToken = true;
    __isset.value = true;
    __isset.flags = true;
    __isset.message = true;
    __isset.appSpecificErrorCode = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McLeaseGetReply(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McLeaseGetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    result = arg.move();
    __isset.result = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McLeaseGetReply(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McLeaseGetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    leaseToken = arg.move();
    __isset.leaseToken = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McLeaseGetReply(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McLeaseGetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    value = arg.move();
    __isset.value = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McLeaseGetReply(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McLeaseGetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    flags = arg.move();
    __isset.flags = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McLeaseGetReply(::apache::thrift::detail::argument_wrapper<5, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McLeaseGetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    message = arg.move();
    __isset.message = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McLeaseGetReply(::apache::thrift::detail::argument_wrapper<6, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McLeaseGetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    appSpecificErrorCode = arg.move();
    __isset.appSpecificErrorCode = true;
  }

  McLeaseGetReply(McLeaseGetReply&&) = default;

  McLeaseGetReply(const McLeaseGetReply&) = default;

  McLeaseGetReply& operator=(McLeaseGetReply&&) = default;

  McLeaseGetReply& operator=(const McLeaseGetReply&) = default;
  void __clear();

  virtual ~McLeaseGetReply() throw() {}

  int16_t result;
  int64_t leaseToken;
   ::facebook::memcache::cpp2::IOBuf value;
  int64_t flags;
  std::string message;
  int16_t appSpecificErrorCode;

  struct __isset {
    void __clear() {
      result = false;
      leaseToken = false;
      value = false;
      flags = false;
      message = false;
      appSpecificErrorCode = false;
    }

    bool result = false;
    bool leaseToken = false;
    bool value = false;
    bool flags = false;
    bool message = false;
    bool appSpecificErrorCode = false;
  } __isset;
  bool operator==(const McLeaseGetReply& rhs) const;
  bool operator < (const McLeaseGetReply& rhs) const;

  int16_t get_result() const {
    return result;
  }

  int16_t& set_result(int16_t result_) {
    result = result_;
    __isset.result = true;
    return result;
  }

  const int64_t* get_leaseToken() const& {
    return __isset.leaseToken ? std::addressof(leaseToken) : nullptr;
  }

  int64_t* get_leaseToken() & {
    return __isset.leaseToken ? std::addressof(leaseToken) : nullptr;
  }
  int64_t* get_leaseToken() && = delete;

  int64_t& set_leaseToken(int64_t leaseToken_) {
    leaseToken = leaseToken_;
    __isset.leaseToken = true;
    return leaseToken;
  }

  const  ::facebook::memcache::cpp2::IOBuf* get_value() const& {
    return __isset.value ? std::addressof(value) : nullptr;
  }

   ::facebook::memcache::cpp2::IOBuf* get_value() & {
    return __isset.value ? std::addressof(value) : nullptr;
  }
   ::facebook::memcache::cpp2::IOBuf* get_value() && = delete;

  template <typename T_McLeaseGetReply_value_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_value(T_McLeaseGetReply_value_struct_setter&& value_) {
    value = std::forward<T_McLeaseGetReply_value_struct_setter>(value_);
    __isset.value = true;
    return value;
  }

  const int64_t* get_flags() const& {
    return __isset.flags ? std::addressof(flags) : nullptr;
  }

  int64_t* get_flags() & {
    return __isset.flags ? std::addressof(flags) : nullptr;
  }
  int64_t* get_flags() && = delete;

  int64_t& set_flags(int64_t flags_) {
    flags = flags_;
    __isset.flags = true;
    return flags;
  }

  const std::string* get_message() const& {
    return __isset.message ? std::addressof(message) : nullptr;
  }

  std::string* get_message() & {
    return __isset.message ? std::addressof(message) : nullptr;
  }
  std::string* get_message() && = delete;

  template <typename T_McLeaseGetReply_message_struct_setter>
  std::string& set_message(T_McLeaseGetReply_message_struct_setter&& message_) {
    message = std::forward<T_McLeaseGetReply_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  const int16_t* get_appSpecificErrorCode() const& {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }

  int16_t* get_appSpecificErrorCode() & {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }
  int16_t* get_appSpecificErrorCode() && = delete;

  int16_t& set_appSpecificErrorCode(int16_t appSpecificErrorCode_) {
    appSpecificErrorCode = appSpecificErrorCode_;
    __isset.appSpecificErrorCode = true;
    return appSpecificErrorCode;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McLeaseGetReply& a, McLeaseGetReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McLeaseGetReply>::clear( ::facebook::memcache::cpp2::McLeaseGetReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McLeaseGetReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseGetReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McLeaseGetReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseGetReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McLeaseGetReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseGetReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McLeaseGetReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseGetReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McLeaseGetReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McLeaseSetRequest : private boost::totally_ordered<McLeaseSetRequest> {
 public:

  McLeaseSetRequest() :
      exptime(0),
      flags(0),
      leaseToken(0) {}
  // FragileConstructor for use in initialization lists only

  McLeaseSetRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg, int32_t exptime__arg, int64_t flags__arg,  ::facebook::memcache::cpp2::IOBuf value__arg, int64_t leaseToken__arg) :
      key(std::move(key__arg)),
      exptime(std::move(exptime__arg)),
      flags(std::move(flags__arg)),
      value(std::move(value__arg)),
      leaseToken(std::move(leaseToken__arg)) {
    __isset.key = true;
    __isset.exptime = true;
    __isset.flags = true;
    __isset.value = true;
    __isset.leaseToken = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McLeaseSetRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McLeaseSetRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    key = arg.move();
    __isset.key = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McLeaseSetRequest(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McLeaseSetRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    exptime = arg.move();
    __isset.exptime = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McLeaseSetRequest(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McLeaseSetRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    flags = arg.move();
    __isset.flags = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McLeaseSetRequest(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McLeaseSetRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    value = arg.move();
    __isset.value = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McLeaseSetRequest(::apache::thrift::detail::argument_wrapper<5, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McLeaseSetRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    leaseToken = arg.move();
    __isset.leaseToken = true;
  }

  McLeaseSetRequest(McLeaseSetRequest&&) = default;

  McLeaseSetRequest(const McLeaseSetRequest&) = default;

  McLeaseSetRequest& operator=(McLeaseSetRequest&&) = default;

  McLeaseSetRequest& operator=(const McLeaseSetRequest&) = default;
  void __clear();

  virtual ~McLeaseSetRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;
  int32_t exptime;
  int64_t flags;
   ::facebook::memcache::cpp2::IOBuf value;
  int64_t leaseToken;

  struct __isset {
    void __clear() {
      key = false;
      exptime = false;
      flags = false;
      value = false;
      leaseToken = false;
    }

    bool key = false;
    bool exptime = false;
    bool flags = false;
    bool value = false;
    bool leaseToken = false;
  } __isset;
  bool operator==(const McLeaseSetRequest& rhs) const;
  bool operator < (const McLeaseSetRequest& rhs) const;

  const  ::facebook::memcache::cpp2::IOBuf& get_key() const& {
    return key;
  }

   ::facebook::memcache::cpp2::IOBuf get_key() && {
    return std::move(key);
  }

  template <typename T_McLeaseSetRequest_key_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_key(T_McLeaseSetRequest_key_struct_setter&& key_) {
    key = std::forward<T_McLeaseSetRequest_key_struct_setter>(key_);
    __isset.key = true;
    return key;
  }

  int32_t get_exptime() const {
    return exptime;
  }

  int32_t& set_exptime(int32_t exptime_) {
    exptime = exptime_;
    __isset.exptime = true;
    return exptime;
  }

  int64_t get_flags() const {
    return flags;
  }

  int64_t& set_flags(int64_t flags_) {
    flags = flags_;
    __isset.flags = true;
    return flags;
  }

  const  ::facebook::memcache::cpp2::IOBuf& get_value() const& {
    return value;
  }

   ::facebook::memcache::cpp2::IOBuf get_value() && {
    return std::move(value);
  }

  template <typename T_McLeaseSetRequest_value_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_value(T_McLeaseSetRequest_value_struct_setter&& value_) {
    value = std::forward<T_McLeaseSetRequest_value_struct_setter>(value_);
    __isset.value = true;
    return value;
  }

  int64_t get_leaseToken() const {
    return leaseToken;
  }

  int64_t& set_leaseToken(int64_t leaseToken_) {
    leaseToken = leaseToken_;
    __isset.leaseToken = true;
    return leaseToken;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McLeaseSetRequest& a, McLeaseSetRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McLeaseSetRequest>::clear( ::facebook::memcache::cpp2::McLeaseSetRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McLeaseSetRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseSetRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McLeaseSetRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseSetRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McLeaseSetRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseSetRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McLeaseSetRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseSetRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McLeaseSetRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McLeaseSetReply : private boost::totally_ordered<McLeaseSetReply> {
 public:

  McLeaseSetReply() :
      result(0),
      appSpecificErrorCode(0) {}
  // FragileConstructor for use in initialization lists only

  McLeaseSetReply(apache::thrift::FragileConstructor, int16_t result__arg, std::string message__arg, int16_t appSpecificErrorCode__arg) :
      result(std::move(result__arg)),
      message(std::move(message__arg)),
      appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
    __isset.result = true;
    __isset.message = true;
    __isset.appSpecificErrorCode = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McLeaseSetReply(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McLeaseSetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    result = arg.move();
    __isset.result = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McLeaseSetReply(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McLeaseSetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    message = arg.move();
    __isset.message = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McLeaseSetReply(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McLeaseSetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    appSpecificErrorCode = arg.move();
    __isset.appSpecificErrorCode = true;
  }

  McLeaseSetReply(McLeaseSetReply&&) = default;

  McLeaseSetReply(const McLeaseSetReply&) = default;

  McLeaseSetReply& operator=(McLeaseSetReply&&) = default;

  McLeaseSetReply& operator=(const McLeaseSetReply&) = default;
  void __clear();

  virtual ~McLeaseSetReply() throw() {}

  int16_t result;
  std::string message;
  int16_t appSpecificErrorCode;

  struct __isset {
    void __clear() {
      result = false;
      message = false;
      appSpecificErrorCode = false;
    }

    bool result = false;
    bool message = false;
    bool appSpecificErrorCode = false;
  } __isset;
  bool operator==(const McLeaseSetReply& rhs) const;
  bool operator < (const McLeaseSetReply& rhs) const;

  int16_t get_result() const {
    return result;
  }

  int16_t& set_result(int16_t result_) {
    result = result_;
    __isset.result = true;
    return result;
  }

  const std::string* get_message() const& {
    return __isset.message ? std::addressof(message) : nullptr;
  }

  std::string* get_message() & {
    return __isset.message ? std::addressof(message) : nullptr;
  }
  std::string* get_message() && = delete;

  template <typename T_McLeaseSetReply_message_struct_setter>
  std::string& set_message(T_McLeaseSetReply_message_struct_setter&& message_) {
    message = std::forward<T_McLeaseSetReply_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  const int16_t* get_appSpecificErrorCode() const& {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }

  int16_t* get_appSpecificErrorCode() & {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }
  int16_t* get_appSpecificErrorCode() && = delete;

  int16_t& set_appSpecificErrorCode(int16_t appSpecificErrorCode_) {
    appSpecificErrorCode = appSpecificErrorCode_;
    __isset.appSpecificErrorCode = true;
    return appSpecificErrorCode;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McLeaseSetReply& a, McLeaseSetReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McLeaseSetReply>::clear( ::facebook::memcache::cpp2::McLeaseSetReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McLeaseSetReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseSetReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McLeaseSetReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseSetReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McLeaseSetReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseSetReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McLeaseSetReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseSetReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McLeaseSetReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McAddRequest : private boost::totally_ordered<McAddRequest> {
 public:

  McAddRequest() :
      exptime(0),
      flags(0) {}
  // FragileConstructor for use in initialization lists only

  McAddRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg, int32_t exptime__arg, int64_t flags__arg,  ::facebook::memcache::cpp2::IOBuf value__arg) :
      key(std::move(key__arg)),
      exptime(std::move(exptime__arg)),
      flags(std::move(flags__arg)),
      value(std::move(value__arg)) {
    __isset.key = true;
    __isset.exptime = true;
    __isset.flags = true;
    __isset.value = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McAddRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McAddRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    key = arg.move();
    __isset.key = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McAddRequest(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McAddRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    exptime = arg.move();
    __isset.exptime = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McAddRequest(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McAddRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    flags = arg.move();
    __isset.flags = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McAddRequest(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McAddRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    value = arg.move();
    __isset.value = true;
  }

  McAddRequest(McAddRequest&&) = default;

  McAddRequest(const McAddRequest&) = default;

  McAddRequest& operator=(McAddRequest&&) = default;

  McAddRequest& operator=(const McAddRequest&) = default;
  void __clear();

  virtual ~McAddRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;
  int32_t exptime;
  int64_t flags;
   ::facebook::memcache::cpp2::IOBuf value;

  struct __isset {
    void __clear() {
      key = false;
      exptime = false;
      flags = false;
      value = false;
    }

    bool key = false;
    bool exptime = false;
    bool flags = false;
    bool value = false;
  } __isset;
  bool operator==(const McAddRequest& rhs) const;
  bool operator < (const McAddRequest& rhs) const;

  const  ::facebook::memcache::cpp2::IOBuf& get_key() const& {
    return key;
  }

   ::facebook::memcache::cpp2::IOBuf get_key() && {
    return std::move(key);
  }

  template <typename T_McAddRequest_key_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_key(T_McAddRequest_key_struct_setter&& key_) {
    key = std::forward<T_McAddRequest_key_struct_setter>(key_);
    __isset.key = true;
    return key;
  }

  int32_t get_exptime() const {
    return exptime;
  }

  int32_t& set_exptime(int32_t exptime_) {
    exptime = exptime_;
    __isset.exptime = true;
    return exptime;
  }

  int64_t get_flags() const {
    return flags;
  }

  int64_t& set_flags(int64_t flags_) {
    flags = flags_;
    __isset.flags = true;
    return flags;
  }

  const  ::facebook::memcache::cpp2::IOBuf& get_value() const& {
    return value;
  }

   ::facebook::memcache::cpp2::IOBuf get_value() && {
    return std::move(value);
  }

  template <typename T_McAddRequest_value_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_value(T_McAddRequest_value_struct_setter&& value_) {
    value = std::forward<T_McAddRequest_value_struct_setter>(value_);
    __isset.value = true;
    return value;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McAddRequest& a, McAddRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McAddRequest>::clear( ::facebook::memcache::cpp2::McAddRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McAddRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAddRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McAddRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAddRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McAddRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAddRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McAddRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAddRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McAddRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McAddReply : private boost::totally_ordered<McAddReply> {
 public:

  McAddReply() :
      result(0),
      appSpecificErrorCode(0) {}
  // FragileConstructor for use in initialization lists only

  McAddReply(apache::thrift::FragileConstructor, int16_t result__arg, std::string message__arg, int16_t appSpecificErrorCode__arg) :
      result(std::move(result__arg)),
      message(std::move(message__arg)),
      appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
    __isset.result = true;
    __isset.message = true;
    __isset.appSpecificErrorCode = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McAddReply(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McAddReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    result = arg.move();
    __isset.result = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McAddReply(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McAddReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    message = arg.move();
    __isset.message = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McAddReply(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McAddReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    appSpecificErrorCode = arg.move();
    __isset.appSpecificErrorCode = true;
  }

  McAddReply(McAddReply&&) = default;

  McAddReply(const McAddReply&) = default;

  McAddReply& operator=(McAddReply&&) = default;

  McAddReply& operator=(const McAddReply&) = default;
  void __clear();

  virtual ~McAddReply() throw() {}

  int16_t result;
  std::string message;
  int16_t appSpecificErrorCode;

  struct __isset {
    void __clear() {
      result = false;
      message = false;
      appSpecificErrorCode = false;
    }

    bool result = false;
    bool message = false;
    bool appSpecificErrorCode = false;
  } __isset;
  bool operator==(const McAddReply& rhs) const;
  bool operator < (const McAddReply& rhs) const;

  int16_t get_result() const {
    return result;
  }

  int16_t& set_result(int16_t result_) {
    result = result_;
    __isset.result = true;
    return result;
  }

  const std::string* get_message() const& {
    return __isset.message ? std::addressof(message) : nullptr;
  }

  std::string* get_message() & {
    return __isset.message ? std::addressof(message) : nullptr;
  }
  std::string* get_message() && = delete;

  template <typename T_McAddReply_message_struct_setter>
  std::string& set_message(T_McAddReply_message_struct_setter&& message_) {
    message = std::forward<T_McAddReply_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  const int16_t* get_appSpecificErrorCode() const& {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }

  int16_t* get_appSpecificErrorCode() & {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }
  int16_t* get_appSpecificErrorCode() && = delete;

  int16_t& set_appSpecificErrorCode(int16_t appSpecificErrorCode_) {
    appSpecificErrorCode = appSpecificErrorCode_;
    __isset.appSpecificErrorCode = true;
    return appSpecificErrorCode;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McAddReply& a, McAddReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McAddReply>::clear( ::facebook::memcache::cpp2::McAddReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McAddReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAddReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McAddReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAddReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McAddReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAddReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McAddReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAddReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McAddReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McReplaceRequest : private boost::totally_ordered<McReplaceRequest> {
 public:

  McReplaceRequest() :
      exptime(0),
      flags(0) {}
  // FragileConstructor for use in initialization lists only

  McReplaceRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg, int32_t exptime__arg, int64_t flags__arg,  ::facebook::memcache::cpp2::IOBuf value__arg) :
      key(std::move(key__arg)),
      exptime(std::move(exptime__arg)),
      flags(std::move(flags__arg)),
      value(std::move(value__arg)) {
    __isset.key = true;
    __isset.exptime = true;
    __isset.flags = true;
    __isset.value = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McReplaceRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McReplaceRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    key = arg.move();
    __isset.key = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McReplaceRequest(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McReplaceRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    exptime = arg.move();
    __isset.exptime = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McReplaceRequest(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McReplaceRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    flags = arg.move();
    __isset.flags = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McReplaceRequest(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McReplaceRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    value = arg.move();
    __isset.value = true;
  }

  McReplaceRequest(McReplaceRequest&&) = default;

  McReplaceRequest(const McReplaceRequest&) = default;

  McReplaceRequest& operator=(McReplaceRequest&&) = default;

  McReplaceRequest& operator=(const McReplaceRequest&) = default;
  void __clear();

  virtual ~McReplaceRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;
  int32_t exptime;
  int64_t flags;
   ::facebook::memcache::cpp2::IOBuf value;

  struct __isset {
    void __clear() {
      key = false;
      exptime = false;
      flags = false;
      value = false;
    }

    bool key = false;
    bool exptime = false;
    bool flags = false;
    bool value = false;
  } __isset;
  bool operator==(const McReplaceRequest& rhs) const;
  bool operator < (const McReplaceRequest& rhs) const;

  const  ::facebook::memcache::cpp2::IOBuf& get_key() const& {
    return key;
  }

   ::facebook::memcache::cpp2::IOBuf get_key() && {
    return std::move(key);
  }

  template <typename T_McReplaceRequest_key_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_key(T_McReplaceRequest_key_struct_setter&& key_) {
    key = std::forward<T_McReplaceRequest_key_struct_setter>(key_);
    __isset.key = true;
    return key;
  }

  int32_t get_exptime() const {
    return exptime;
  }

  int32_t& set_exptime(int32_t exptime_) {
    exptime = exptime_;
    __isset.exptime = true;
    return exptime;
  }

  int64_t get_flags() const {
    return flags;
  }

  int64_t& set_flags(int64_t flags_) {
    flags = flags_;
    __isset.flags = true;
    return flags;
  }

  const  ::facebook::memcache::cpp2::IOBuf& get_value() const& {
    return value;
  }

   ::facebook::memcache::cpp2::IOBuf get_value() && {
    return std::move(value);
  }

  template <typename T_McReplaceRequest_value_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_value(T_McReplaceRequest_value_struct_setter&& value_) {
    value = std::forward<T_McReplaceRequest_value_struct_setter>(value_);
    __isset.value = true;
    return value;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McReplaceRequest& a, McReplaceRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McReplaceRequest>::clear( ::facebook::memcache::cpp2::McReplaceRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McReplaceRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McReplaceRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McReplaceRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McReplaceRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McReplaceRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McReplaceRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McReplaceRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McReplaceRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McReplaceRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McReplaceReply : private boost::totally_ordered<McReplaceReply> {
 public:

  McReplaceReply() :
      result(0),
      appSpecificErrorCode(0) {}
  // FragileConstructor for use in initialization lists only

  McReplaceReply(apache::thrift::FragileConstructor, int16_t result__arg, std::string message__arg, int16_t appSpecificErrorCode__arg) :
      result(std::move(result__arg)),
      message(std::move(message__arg)),
      appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
    __isset.result = true;
    __isset.message = true;
    __isset.appSpecificErrorCode = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McReplaceReply(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McReplaceReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    result = arg.move();
    __isset.result = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McReplaceReply(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McReplaceReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    message = arg.move();
    __isset.message = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McReplaceReply(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McReplaceReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    appSpecificErrorCode = arg.move();
    __isset.appSpecificErrorCode = true;
  }

  McReplaceReply(McReplaceReply&&) = default;

  McReplaceReply(const McReplaceReply&) = default;

  McReplaceReply& operator=(McReplaceReply&&) = default;

  McReplaceReply& operator=(const McReplaceReply&) = default;
  void __clear();

  virtual ~McReplaceReply() throw() {}

  int16_t result;
  std::string message;
  int16_t appSpecificErrorCode;

  struct __isset {
    void __clear() {
      result = false;
      message = false;
      appSpecificErrorCode = false;
    }

    bool result = false;
    bool message = false;
    bool appSpecificErrorCode = false;
  } __isset;
  bool operator==(const McReplaceReply& rhs) const;
  bool operator < (const McReplaceReply& rhs) const;

  int16_t get_result() const {
    return result;
  }

  int16_t& set_result(int16_t result_) {
    result = result_;
    __isset.result = true;
    return result;
  }

  const std::string* get_message() const& {
    return __isset.message ? std::addressof(message) : nullptr;
  }

  std::string* get_message() & {
    return __isset.message ? std::addressof(message) : nullptr;
  }
  std::string* get_message() && = delete;

  template <typename T_McReplaceReply_message_struct_setter>
  std::string& set_message(T_McReplaceReply_message_struct_setter&& message_) {
    message = std::forward<T_McReplaceReply_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  const int16_t* get_appSpecificErrorCode() const& {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }

  int16_t* get_appSpecificErrorCode() & {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }
  int16_t* get_appSpecificErrorCode() && = delete;

  int16_t& set_appSpecificErrorCode(int16_t appSpecificErrorCode_) {
    appSpecificErrorCode = appSpecificErrorCode_;
    __isset.appSpecificErrorCode = true;
    return appSpecificErrorCode;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McReplaceReply& a, McReplaceReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McReplaceReply>::clear( ::facebook::memcache::cpp2::McReplaceReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McReplaceReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McReplaceReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McReplaceReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McReplaceReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McReplaceReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McReplaceReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McReplaceReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McReplaceReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McReplaceReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McGetsRequest : private boost::totally_ordered<McGetsRequest> {
 public:

  McGetsRequest() {}
  // FragileConstructor for use in initialization lists only

  McGetsRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg) :
      key(std::move(key__arg)) {
    __isset.key = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McGetsRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McGetsRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    key = arg.move();
    __isset.key = true;
  }

  McGetsRequest(McGetsRequest&&) = default;

  McGetsRequest(const McGetsRequest&) = default;

  McGetsRequest& operator=(McGetsRequest&&) = default;

  McGetsRequest& operator=(const McGetsRequest&) = default;
  void __clear();

  virtual ~McGetsRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;

  struct __isset {
    void __clear() {
      key = false;
    }

    bool key = false;
  } __isset;
  bool operator==(const McGetsRequest& rhs) const;
  bool operator < (const McGetsRequest& rhs) const;

  const  ::facebook::memcache::cpp2::IOBuf& get_key() const& {
    return key;
  }

   ::facebook::memcache::cpp2::IOBuf get_key() && {
    return std::move(key);
  }

  template <typename T_McGetsRequest_key_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_key(T_McGetsRequest_key_struct_setter&& key_) {
    key = std::forward<T_McGetsRequest_key_struct_setter>(key_);
    __isset.key = true;
    return key;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McGetsRequest& a, McGetsRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McGetsRequest>::clear( ::facebook::memcache::cpp2::McGetsRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McGetsRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetsRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McGetsRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetsRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McGetsRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetsRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McGetsRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetsRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McGetsRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McGetsReply : private boost::totally_ordered<McGetsReply> {
 public:

  McGetsReply() :
      result(0),
      casToken(0),
      flags(0),
      appSpecificErrorCode(0) {}
  // FragileConstructor for use in initialization lists only

  McGetsReply(apache::thrift::FragileConstructor, int16_t result__arg, int64_t casToken__arg,  ::facebook::memcache::cpp2::IOBuf value__arg, int64_t flags__arg, std::string message__arg, int16_t appSpecificErrorCode__arg) :
      result(std::move(result__arg)),
      casToken(std::move(casToken__arg)),
      value(std::move(value__arg)),
      flags(std::move(flags__arg)),
      message(std::move(message__arg)),
      appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
    __isset.result = true;
    __isset.casToken = true;
    __isset.value = true;
    __isset.flags = true;
    __isset.message = true;
    __isset.appSpecificErrorCode = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McGetsReply(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McGetsReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    result = arg.move();
    __isset.result = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McGetsReply(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McGetsReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    casToken = arg.move();
    __isset.casToken = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McGetsReply(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McGetsReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    value = arg.move();
    __isset.value = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McGetsReply(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McGetsReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    flags = arg.move();
    __isset.flags = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McGetsReply(::apache::thrift::detail::argument_wrapper<5, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McGetsReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    message = arg.move();
    __isset.message = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McGetsReply(::apache::thrift::detail::argument_wrapper<6, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McGetsReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    appSpecificErrorCode = arg.move();
    __isset.appSpecificErrorCode = true;
  }

  McGetsReply(McGetsReply&&) = default;

  McGetsReply(const McGetsReply&) = default;

  McGetsReply& operator=(McGetsReply&&) = default;

  McGetsReply& operator=(const McGetsReply&) = default;
  void __clear();

  virtual ~McGetsReply() throw() {}

  int16_t result;
  int64_t casToken;
   ::facebook::memcache::cpp2::IOBuf value;
  int64_t flags;
  std::string message;
  int16_t appSpecificErrorCode;

  struct __isset {
    void __clear() {
      result = false;
      casToken = false;
      value = false;
      flags = false;
      message = false;
      appSpecificErrorCode = false;
    }

    bool result = false;
    bool casToken = false;
    bool value = false;
    bool flags = false;
    bool message = false;
    bool appSpecificErrorCode = false;
  } __isset;
  bool operator==(const McGetsReply& rhs) const;
  bool operator < (const McGetsReply& rhs) const;

  int16_t get_result() const {
    return result;
  }

  int16_t& set_result(int16_t result_) {
    result = result_;
    __isset.result = true;
    return result;
  }

  const int64_t* get_casToken() const& {
    return __isset.casToken ? std::addressof(casToken) : nullptr;
  }

  int64_t* get_casToken() & {
    return __isset.casToken ? std::addressof(casToken) : nullptr;
  }
  int64_t* get_casToken() && = delete;

  int64_t& set_casToken(int64_t casToken_) {
    casToken = casToken_;
    __isset.casToken = true;
    return casToken;
  }

  const  ::facebook::memcache::cpp2::IOBuf* get_value() const& {
    return __isset.value ? std::addressof(value) : nullptr;
  }

   ::facebook::memcache::cpp2::IOBuf* get_value() & {
    return __isset.value ? std::addressof(value) : nullptr;
  }
   ::facebook::memcache::cpp2::IOBuf* get_value() && = delete;

  template <typename T_McGetsReply_value_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_value(T_McGetsReply_value_struct_setter&& value_) {
    value = std::forward<T_McGetsReply_value_struct_setter>(value_);
    __isset.value = true;
    return value;
  }

  const int64_t* get_flags() const& {
    return __isset.flags ? std::addressof(flags) : nullptr;
  }

  int64_t* get_flags() & {
    return __isset.flags ? std::addressof(flags) : nullptr;
  }
  int64_t* get_flags() && = delete;

  int64_t& set_flags(int64_t flags_) {
    flags = flags_;
    __isset.flags = true;
    return flags;
  }

  const std::string* get_message() const& {
    return __isset.message ? std::addressof(message) : nullptr;
  }

  std::string* get_message() & {
    return __isset.message ? std::addressof(message) : nullptr;
  }
  std::string* get_message() && = delete;

  template <typename T_McGetsReply_message_struct_setter>
  std::string& set_message(T_McGetsReply_message_struct_setter&& message_) {
    message = std::forward<T_McGetsReply_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  const int16_t* get_appSpecificErrorCode() const& {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }

  int16_t* get_appSpecificErrorCode() & {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }
  int16_t* get_appSpecificErrorCode() && = delete;

  int16_t& set_appSpecificErrorCode(int16_t appSpecificErrorCode_) {
    appSpecificErrorCode = appSpecificErrorCode_;
    __isset.appSpecificErrorCode = true;
    return appSpecificErrorCode;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McGetsReply& a, McGetsReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McGetsReply>::clear( ::facebook::memcache::cpp2::McGetsReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McGetsReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetsReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McGetsReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetsReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McGetsReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetsReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McGetsReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetsReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McGetsReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McCasRequest : private boost::totally_ordered<McCasRequest> {
 public:

  McCasRequest() :
      exptime(0),
      flags(0),
      casToken(0) {}
  // FragileConstructor for use in initialization lists only

  McCasRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg, int32_t exptime__arg, int64_t flags__arg,  ::facebook::memcache::cpp2::IOBuf value__arg, int64_t casToken__arg) :
      key(std::move(key__arg)),
      exptime(std::move(exptime__arg)),
      flags(std::move(flags__arg)),
      value(std::move(value__arg)),
      casToken(std::move(casToken__arg)) {
    __isset.key = true;
    __isset.exptime = true;
    __isset.flags = true;
    __isset.value = true;
    __isset.casToken = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McCasRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McCasRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    key = arg.move();
    __isset.key = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McCasRequest(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McCasRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    exptime = arg.move();
    __isset.exptime = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McCasRequest(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McCasRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    flags = arg.move();
    __isset.flags = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McCasRequest(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McCasRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    value = arg.move();
    __isset.value = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McCasRequest(::apache::thrift::detail::argument_wrapper<5, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McCasRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    casToken = arg.move();
    __isset.casToken = true;
  }

  McCasRequest(McCasRequest&&) = default;

  McCasRequest(const McCasRequest&) = default;

  McCasRequest& operator=(McCasRequest&&) = default;

  McCasRequest& operator=(const McCasRequest&) = default;
  void __clear();

  virtual ~McCasRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;
  int32_t exptime;
  int64_t flags;
   ::facebook::memcache::cpp2::IOBuf value;
  int64_t casToken;

  struct __isset {
    void __clear() {
      key = false;
      exptime = false;
      flags = false;
      value = false;
      casToken = false;
    }

    bool key = false;
    bool exptime = false;
    bool flags = false;
    bool value = false;
    bool casToken = false;
  } __isset;
  bool operator==(const McCasRequest& rhs) const;
  bool operator < (const McCasRequest& rhs) const;

  const  ::facebook::memcache::cpp2::IOBuf& get_key() const& {
    return key;
  }

   ::facebook::memcache::cpp2::IOBuf get_key() && {
    return std::move(key);
  }

  template <typename T_McCasRequest_key_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_key(T_McCasRequest_key_struct_setter&& key_) {
    key = std::forward<T_McCasRequest_key_struct_setter>(key_);
    __isset.key = true;
    return key;
  }

  int32_t get_exptime() const {
    return exptime;
  }

  int32_t& set_exptime(int32_t exptime_) {
    exptime = exptime_;
    __isset.exptime = true;
    return exptime;
  }

  int64_t get_flags() const {
    return flags;
  }

  int64_t& set_flags(int64_t flags_) {
    flags = flags_;
    __isset.flags = true;
    return flags;
  }

  const  ::facebook::memcache::cpp2::IOBuf& get_value() const& {
    return value;
  }

   ::facebook::memcache::cpp2::IOBuf get_value() && {
    return std::move(value);
  }

  template <typename T_McCasRequest_value_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_value(T_McCasRequest_value_struct_setter&& value_) {
    value = std::forward<T_McCasRequest_value_struct_setter>(value_);
    __isset.value = true;
    return value;
  }

  int64_t get_casToken() const {
    return casToken;
  }

  int64_t& set_casToken(int64_t casToken_) {
    casToken = casToken_;
    __isset.casToken = true;
    return casToken;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McCasRequest& a, McCasRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McCasRequest>::clear( ::facebook::memcache::cpp2::McCasRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McCasRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McCasRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McCasRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McCasRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McCasRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McCasRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McCasRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McCasRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McCasRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McCasReply : private boost::totally_ordered<McCasReply> {
 public:

  McCasReply() :
      result(0),
      appSpecificErrorCode(0) {}
  // FragileConstructor for use in initialization lists only

  McCasReply(apache::thrift::FragileConstructor, int16_t result__arg, std::string message__arg, int16_t appSpecificErrorCode__arg) :
      result(std::move(result__arg)),
      message(std::move(message__arg)),
      appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
    __isset.result = true;
    __isset.message = true;
    __isset.appSpecificErrorCode = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McCasReply(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McCasReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    result = arg.move();
    __isset.result = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McCasReply(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McCasReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    message = arg.move();
    __isset.message = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McCasReply(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McCasReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    appSpecificErrorCode = arg.move();
    __isset.appSpecificErrorCode = true;
  }

  McCasReply(McCasReply&&) = default;

  McCasReply(const McCasReply&) = default;

  McCasReply& operator=(McCasReply&&) = default;

  McCasReply& operator=(const McCasReply&) = default;
  void __clear();

  virtual ~McCasReply() throw() {}

  int16_t result;
  std::string message;
  int16_t appSpecificErrorCode;

  struct __isset {
    void __clear() {
      result = false;
      message = false;
      appSpecificErrorCode = false;
    }

    bool result = false;
    bool message = false;
    bool appSpecificErrorCode = false;
  } __isset;
  bool operator==(const McCasReply& rhs) const;
  bool operator < (const McCasReply& rhs) const;

  int16_t get_result() const {
    return result;
  }

  int16_t& set_result(int16_t result_) {
    result = result_;
    __isset.result = true;
    return result;
  }

  const std::string* get_message() const& {
    return __isset.message ? std::addressof(message) : nullptr;
  }

  std::string* get_message() & {
    return __isset.message ? std::addressof(message) : nullptr;
  }
  std::string* get_message() && = delete;

  template <typename T_McCasReply_message_struct_setter>
  std::string& set_message(T_McCasReply_message_struct_setter&& message_) {
    message = std::forward<T_McCasReply_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  const int16_t* get_appSpecificErrorCode() const& {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }

  int16_t* get_appSpecificErrorCode() & {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }
  int16_t* get_appSpecificErrorCode() && = delete;

  int16_t& set_appSpecificErrorCode(int16_t appSpecificErrorCode_) {
    appSpecificErrorCode = appSpecificErrorCode_;
    __isset.appSpecificErrorCode = true;
    return appSpecificErrorCode;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McCasReply& a, McCasReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McCasReply>::clear( ::facebook::memcache::cpp2::McCasReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McCasReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McCasReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McCasReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McCasReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McCasReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McCasReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McCasReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McCasReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McCasReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McIncrRequest : private boost::totally_ordered<McIncrRequest> {
 public:

  McIncrRequest() :
      delta(0) {}
  // FragileConstructor for use in initialization lists only

  McIncrRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg, int64_t delta__arg) :
      key(std::move(key__arg)),
      delta(std::move(delta__arg)) {
    __isset.key = true;
    __isset.delta = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McIncrRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McIncrRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    key = arg.move();
    __isset.key = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McIncrRequest(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McIncrRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    delta = arg.move();
    __isset.delta = true;
  }

  McIncrRequest(McIncrRequest&&) = default;

  McIncrRequest(const McIncrRequest&) = default;

  McIncrRequest& operator=(McIncrRequest&&) = default;

  McIncrRequest& operator=(const McIncrRequest&) = default;
  void __clear();

  virtual ~McIncrRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;
  int64_t delta;

  struct __isset {
    void __clear() {
      key = false;
      delta = false;
    }

    bool key = false;
    bool delta = false;
  } __isset;
  bool operator==(const McIncrRequest& rhs) const;
  bool operator < (const McIncrRequest& rhs) const;

  const  ::facebook::memcache::cpp2::IOBuf& get_key() const& {
    return key;
  }

   ::facebook::memcache::cpp2::IOBuf get_key() && {
    return std::move(key);
  }

  template <typename T_McIncrRequest_key_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_key(T_McIncrRequest_key_struct_setter&& key_) {
    key = std::forward<T_McIncrRequest_key_struct_setter>(key_);
    __isset.key = true;
    return key;
  }

  int64_t get_delta() const {
    return delta;
  }

  int64_t& set_delta(int64_t delta_) {
    delta = delta_;
    __isset.delta = true;
    return delta;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McIncrRequest& a, McIncrRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McIncrRequest>::clear( ::facebook::memcache::cpp2::McIncrRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McIncrRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McIncrRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McIncrRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McIncrRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McIncrRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McIncrRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McIncrRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McIncrRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McIncrRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McIncrReply : private boost::totally_ordered<McIncrReply> {
 public:

  McIncrReply() :
      result(0),
      delta(0),
      appSpecificErrorCode(0) {}
  // FragileConstructor for use in initialization lists only

  McIncrReply(apache::thrift::FragileConstructor, int16_t result__arg, int64_t delta__arg, std::string message__arg, int16_t appSpecificErrorCode__arg) :
      result(std::move(result__arg)),
      delta(std::move(delta__arg)),
      message(std::move(message__arg)),
      appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
    __isset.result = true;
    __isset.delta = true;
    __isset.message = true;
    __isset.appSpecificErrorCode = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McIncrReply(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McIncrReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    result = arg.move();
    __isset.result = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McIncrReply(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McIncrReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    delta = arg.move();
    __isset.delta = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McIncrReply(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McIncrReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    message = arg.move();
    __isset.message = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McIncrReply(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McIncrReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    appSpecificErrorCode = arg.move();
    __isset.appSpecificErrorCode = true;
  }

  McIncrReply(McIncrReply&&) = default;

  McIncrReply(const McIncrReply&) = default;

  McIncrReply& operator=(McIncrReply&&) = default;

  McIncrReply& operator=(const McIncrReply&) = default;
  void __clear();

  virtual ~McIncrReply() throw() {}

  int16_t result;
  int64_t delta;
  std::string message;
  int16_t appSpecificErrorCode;

  struct __isset {
    void __clear() {
      result = false;
      delta = false;
      message = false;
      appSpecificErrorCode = false;
    }

    bool result = false;
    bool delta = false;
    bool message = false;
    bool appSpecificErrorCode = false;
  } __isset;
  bool operator==(const McIncrReply& rhs) const;
  bool operator < (const McIncrReply& rhs) const;

  int16_t get_result() const {
    return result;
  }

  int16_t& set_result(int16_t result_) {
    result = result_;
    __isset.result = true;
    return result;
  }

  const int64_t* get_delta() const& {
    return __isset.delta ? std::addressof(delta) : nullptr;
  }

  int64_t* get_delta() & {
    return __isset.delta ? std::addressof(delta) : nullptr;
  }
  int64_t* get_delta() && = delete;

  int64_t& set_delta(int64_t delta_) {
    delta = delta_;
    __isset.delta = true;
    return delta;
  }

  const std::string* get_message() const& {
    return __isset.message ? std::addressof(message) : nullptr;
  }

  std::string* get_message() & {
    return __isset.message ? std::addressof(message) : nullptr;
  }
  std::string* get_message() && = delete;

  template <typename T_McIncrReply_message_struct_setter>
  std::string& set_message(T_McIncrReply_message_struct_setter&& message_) {
    message = std::forward<T_McIncrReply_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  const int16_t* get_appSpecificErrorCode() const& {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }

  int16_t* get_appSpecificErrorCode() & {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }
  int16_t* get_appSpecificErrorCode() && = delete;

  int16_t& set_appSpecificErrorCode(int16_t appSpecificErrorCode_) {
    appSpecificErrorCode = appSpecificErrorCode_;
    __isset.appSpecificErrorCode = true;
    return appSpecificErrorCode;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McIncrReply& a, McIncrReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McIncrReply>::clear( ::facebook::memcache::cpp2::McIncrReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McIncrReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McIncrReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McIncrReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McIncrReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McIncrReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McIncrReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McIncrReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McIncrReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McIncrReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McDecrRequest : private boost::totally_ordered<McDecrRequest> {
 public:

  McDecrRequest() :
      delta(0) {}
  // FragileConstructor for use in initialization lists only

  McDecrRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg, int64_t delta__arg) :
      key(std::move(key__arg)),
      delta(std::move(delta__arg)) {
    __isset.key = true;
    __isset.delta = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McDecrRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McDecrRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    key = arg.move();
    __isset.key = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McDecrRequest(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McDecrRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    delta = arg.move();
    __isset.delta = true;
  }

  McDecrRequest(McDecrRequest&&) = default;

  McDecrRequest(const McDecrRequest&) = default;

  McDecrRequest& operator=(McDecrRequest&&) = default;

  McDecrRequest& operator=(const McDecrRequest&) = default;
  void __clear();

  virtual ~McDecrRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;
  int64_t delta;

  struct __isset {
    void __clear() {
      key = false;
      delta = false;
    }

    bool key = false;
    bool delta = false;
  } __isset;
  bool operator==(const McDecrRequest& rhs) const;
  bool operator < (const McDecrRequest& rhs) const;

  const  ::facebook::memcache::cpp2::IOBuf& get_key() const& {
    return key;
  }

   ::facebook::memcache::cpp2::IOBuf get_key() && {
    return std::move(key);
  }

  template <typename T_McDecrRequest_key_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_key(T_McDecrRequest_key_struct_setter&& key_) {
    key = std::forward<T_McDecrRequest_key_struct_setter>(key_);
    __isset.key = true;
    return key;
  }

  int64_t get_delta() const {
    return delta;
  }

  int64_t& set_delta(int64_t delta_) {
    delta = delta_;
    __isset.delta = true;
    return delta;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McDecrRequest& a, McDecrRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McDecrRequest>::clear( ::facebook::memcache::cpp2::McDecrRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McDecrRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDecrRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McDecrRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDecrRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McDecrRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDecrRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McDecrRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDecrRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McDecrRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McDecrReply : private boost::totally_ordered<McDecrReply> {
 public:

  McDecrReply() :
      result(0),
      delta(0),
      appSpecificErrorCode(0) {}
  // FragileConstructor for use in initialization lists only

  McDecrReply(apache::thrift::FragileConstructor, int16_t result__arg, int64_t delta__arg, std::string message__arg, int16_t appSpecificErrorCode__arg) :
      result(std::move(result__arg)),
      delta(std::move(delta__arg)),
      message(std::move(message__arg)),
      appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
    __isset.result = true;
    __isset.delta = true;
    __isset.message = true;
    __isset.appSpecificErrorCode = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McDecrReply(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McDecrReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    result = arg.move();
    __isset.result = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McDecrReply(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McDecrReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    delta = arg.move();
    __isset.delta = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McDecrReply(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McDecrReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    message = arg.move();
    __isset.message = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McDecrReply(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McDecrReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    appSpecificErrorCode = arg.move();
    __isset.appSpecificErrorCode = true;
  }

  McDecrReply(McDecrReply&&) = default;

  McDecrReply(const McDecrReply&) = default;

  McDecrReply& operator=(McDecrReply&&) = default;

  McDecrReply& operator=(const McDecrReply&) = default;
  void __clear();

  virtual ~McDecrReply() throw() {}

  int16_t result;
  int64_t delta;
  std::string message;
  int16_t appSpecificErrorCode;

  struct __isset {
    void __clear() {
      result = false;
      delta = false;
      message = false;
      appSpecificErrorCode = false;
    }

    bool result = false;
    bool delta = false;
    bool message = false;
    bool appSpecificErrorCode = false;
  } __isset;
  bool operator==(const McDecrReply& rhs) const;
  bool operator < (const McDecrReply& rhs) const;

  int16_t get_result() const {
    return result;
  }

  int16_t& set_result(int16_t result_) {
    result = result_;
    __isset.result = true;
    return result;
  }

  const int64_t* get_delta() const& {
    return __isset.delta ? std::addressof(delta) : nullptr;
  }

  int64_t* get_delta() & {
    return __isset.delta ? std::addressof(delta) : nullptr;
  }
  int64_t* get_delta() && = delete;

  int64_t& set_delta(int64_t delta_) {
    delta = delta_;
    __isset.delta = true;
    return delta;
  }

  const std::string* get_message() const& {
    return __isset.message ? std::addressof(message) : nullptr;
  }

  std::string* get_message() & {
    return __isset.message ? std::addressof(message) : nullptr;
  }
  std::string* get_message() && = delete;

  template <typename T_McDecrReply_message_struct_setter>
  std::string& set_message(T_McDecrReply_message_struct_setter&& message_) {
    message = std::forward<T_McDecrReply_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  const int16_t* get_appSpecificErrorCode() const& {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }

  int16_t* get_appSpecificErrorCode() & {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }
  int16_t* get_appSpecificErrorCode() && = delete;

  int16_t& set_appSpecificErrorCode(int16_t appSpecificErrorCode_) {
    appSpecificErrorCode = appSpecificErrorCode_;
    __isset.appSpecificErrorCode = true;
    return appSpecificErrorCode;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McDecrReply& a, McDecrReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McDecrReply>::clear( ::facebook::memcache::cpp2::McDecrReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McDecrReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDecrReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McDecrReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDecrReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McDecrReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDecrReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McDecrReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDecrReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McDecrReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McMetagetRequest : private boost::totally_ordered<McMetagetRequest> {
 public:

  McMetagetRequest() {}
  // FragileConstructor for use in initialization lists only

  McMetagetRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg) :
      key(std::move(key__arg)) {
    __isset.key = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McMetagetRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McMetagetRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    key = arg.move();
    __isset.key = true;
  }

  McMetagetRequest(McMetagetRequest&&) = default;

  McMetagetRequest(const McMetagetRequest&) = default;

  McMetagetRequest& operator=(McMetagetRequest&&) = default;

  McMetagetRequest& operator=(const McMetagetRequest&) = default;
  void __clear();

  virtual ~McMetagetRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;

  struct __isset {
    void __clear() {
      key = false;
    }

    bool key = false;
  } __isset;
  bool operator==(const McMetagetRequest& rhs) const;
  bool operator < (const McMetagetRequest& rhs) const;

  const  ::facebook::memcache::cpp2::IOBuf& get_key() const& {
    return key;
  }

   ::facebook::memcache::cpp2::IOBuf get_key() && {
    return std::move(key);
  }

  template <typename T_McMetagetRequest_key_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_key(T_McMetagetRequest_key_struct_setter&& key_) {
    key = std::forward<T_McMetagetRequest_key_struct_setter>(key_);
    __isset.key = true;
    return key;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McMetagetRequest& a, McMetagetRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McMetagetRequest>::clear( ::facebook::memcache::cpp2::McMetagetRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McMetagetRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McMetagetRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McMetagetRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McMetagetRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McMetagetRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McMetagetRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McMetagetRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McMetagetRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McMetagetRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McMetagetReply : private boost::totally_ordered<McMetagetReply> {
 public:

  McMetagetReply() :
      result(0),
      age(0),
      exptime(0),
      ipv(0),
      appSpecificErrorCode(0) {}
  // FragileConstructor for use in initialization lists only

  McMetagetReply(apache::thrift::FragileConstructor, int16_t result__arg, int32_t age__arg, int32_t exptime__arg, int16_t ipv__arg, std::string ipAddress__arg, std::string message__arg, int16_t appSpecificErrorCode__arg) :
      result(std::move(result__arg)),
      age(std::move(age__arg)),
      exptime(std::move(exptime__arg)),
      ipv(std::move(ipv__arg)),
      ipAddress(std::move(ipAddress__arg)),
      message(std::move(message__arg)),
      appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
    __isset.result = true;
    __isset.age = true;
    __isset.exptime = true;
    __isset.ipv = true;
    __isset.ipAddress = true;
    __isset.message = true;
    __isset.appSpecificErrorCode = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McMetagetReply(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McMetagetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    result = arg.move();
    __isset.result = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McMetagetReply(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McMetagetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    age = arg.move();
    __isset.age = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McMetagetReply(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McMetagetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    exptime = arg.move();
    __isset.exptime = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McMetagetReply(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McMetagetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    ipv = arg.move();
    __isset.ipv = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McMetagetReply(::apache::thrift::detail::argument_wrapper<5, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McMetagetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    ipAddress = arg.move();
    __isset.ipAddress = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McMetagetReply(::apache::thrift::detail::argument_wrapper<6, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McMetagetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    message = arg.move();
    __isset.message = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McMetagetReply(::apache::thrift::detail::argument_wrapper<7, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McMetagetReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    appSpecificErrorCode = arg.move();
    __isset.appSpecificErrorCode = true;
  }

  McMetagetReply(McMetagetReply&&) = default;

  McMetagetReply(const McMetagetReply&) = default;

  McMetagetReply& operator=(McMetagetReply&&) = default;

  McMetagetReply& operator=(const McMetagetReply&) = default;
  void __clear();

  virtual ~McMetagetReply() throw() {}

  int16_t result;
  int32_t age;
  int32_t exptime;
  int16_t ipv;
  std::string ipAddress;
  std::string message;
  int16_t appSpecificErrorCode;

  struct __isset {
    void __clear() {
      result = false;
      age = false;
      exptime = false;
      ipv = false;
      ipAddress = false;
      message = false;
      appSpecificErrorCode = false;
    }

    bool result = false;
    bool age = false;
    bool exptime = false;
    bool ipv = false;
    bool ipAddress = false;
    bool message = false;
    bool appSpecificErrorCode = false;
  } __isset;
  bool operator==(const McMetagetReply& rhs) const;
  bool operator < (const McMetagetReply& rhs) const;

  int16_t get_result() const {
    return result;
  }

  int16_t& set_result(int16_t result_) {
    result = result_;
    __isset.result = true;
    return result;
  }

  const int32_t* get_age() const& {
    return __isset.age ? std::addressof(age) : nullptr;
  }

  int32_t* get_age() & {
    return __isset.age ? std::addressof(age) : nullptr;
  }
  int32_t* get_age() && = delete;

  int32_t& set_age(int32_t age_) {
    age = age_;
    __isset.age = true;
    return age;
  }

  const int32_t* get_exptime() const& {
    return __isset.exptime ? std::addressof(exptime) : nullptr;
  }

  int32_t* get_exptime() & {
    return __isset.exptime ? std::addressof(exptime) : nullptr;
  }
  int32_t* get_exptime() && = delete;

  int32_t& set_exptime(int32_t exptime_) {
    exptime = exptime_;
    __isset.exptime = true;
    return exptime;
  }

  const int16_t* get_ipv() const& {
    return __isset.ipv ? std::addressof(ipv) : nullptr;
  }

  int16_t* get_ipv() & {
    return __isset.ipv ? std::addressof(ipv) : nullptr;
  }
  int16_t* get_ipv() && = delete;

  int16_t& set_ipv(int16_t ipv_) {
    ipv = ipv_;
    __isset.ipv = true;
    return ipv;
  }

  const std::string* get_ipAddress() const& {
    return __isset.ipAddress ? std::addressof(ipAddress) : nullptr;
  }

  std::string* get_ipAddress() & {
    return __isset.ipAddress ? std::addressof(ipAddress) : nullptr;
  }
  std::string* get_ipAddress() && = delete;

  template <typename T_McMetagetReply_ipAddress_struct_setter>
  std::string& set_ipAddress(T_McMetagetReply_ipAddress_struct_setter&& ipAddress_) {
    ipAddress = std::forward<T_McMetagetReply_ipAddress_struct_setter>(ipAddress_);
    __isset.ipAddress = true;
    return ipAddress;
  }

  const std::string* get_message() const& {
    return __isset.message ? std::addressof(message) : nullptr;
  }

  std::string* get_message() & {
    return __isset.message ? std::addressof(message) : nullptr;
  }
  std::string* get_message() && = delete;

  template <typename T_McMetagetReply_message_struct_setter>
  std::string& set_message(T_McMetagetReply_message_struct_setter&& message_) {
    message = std::forward<T_McMetagetReply_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  const int16_t* get_appSpecificErrorCode() const& {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }

  int16_t* get_appSpecificErrorCode() & {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }
  int16_t* get_appSpecificErrorCode() && = delete;

  int16_t& set_appSpecificErrorCode(int16_t appSpecificErrorCode_) {
    appSpecificErrorCode = appSpecificErrorCode_;
    __isset.appSpecificErrorCode = true;
    return appSpecificErrorCode;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McMetagetReply& a, McMetagetReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McMetagetReply>::clear( ::facebook::memcache::cpp2::McMetagetReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McMetagetReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McMetagetReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McMetagetReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McMetagetReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McMetagetReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McMetagetReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McMetagetReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McMetagetReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McMetagetReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McVersionRequest : private boost::totally_ordered<McVersionRequest> {
 public:

  McVersionRequest() {}
  // FragileConstructor for use in initialization lists only

  McVersionRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg) :
      key(std::move(key__arg)) {
    __isset.key = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McVersionRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McVersionRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    key = arg.move();
    __isset.key = true;
  }

  McVersionRequest(McVersionRequest&&) = default;

  McVersionRequest(const McVersionRequest&) = default;

  McVersionRequest& operator=(McVersionRequest&&) = default;

  McVersionRequest& operator=(const McVersionRequest&) = default;
  void __clear();

  virtual ~McVersionRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;

  struct __isset {
    void __clear() {
      key = false;
    }

    bool key = false;
  } __isset;
  bool operator==(const McVersionRequest& rhs) const;
  bool operator < (const McVersionRequest& rhs) const;

  const  ::facebook::memcache::cpp2::IOBuf& get_key() const& {
    return key;
  }

   ::facebook::memcache::cpp2::IOBuf get_key() && {
    return std::move(key);
  }

  template <typename T_McVersionRequest_key_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_key(T_McVersionRequest_key_struct_setter&& key_) {
    key = std::forward<T_McVersionRequest_key_struct_setter>(key_);
    __isset.key = true;
    return key;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McVersionRequest& a, McVersionRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McVersionRequest>::clear( ::facebook::memcache::cpp2::McVersionRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McVersionRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McVersionRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McVersionRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McVersionRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McVersionRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McVersionRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McVersionRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McVersionRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McVersionRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McVersionReply : private boost::totally_ordered<McVersionReply> {
 public:

  McVersionReply() :
      result(0),
      appSpecificErrorCode(0) {}
  // FragileConstructor for use in initialization lists only

  McVersionReply(apache::thrift::FragileConstructor, int16_t result__arg,  ::facebook::memcache::cpp2::IOBuf value__arg, std::string message__arg, int16_t appSpecificErrorCode__arg) :
      result(std::move(result__arg)),
      value(std::move(value__arg)),
      message(std::move(message__arg)),
      appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
    __isset.result = true;
    __isset.value = true;
    __isset.message = true;
    __isset.appSpecificErrorCode = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McVersionReply(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McVersionReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    result = arg.move();
    __isset.result = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McVersionReply(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McVersionReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    value = arg.move();
    __isset.value = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McVersionReply(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McVersionReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    message = arg.move();
    __isset.message = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McVersionReply(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McVersionReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    appSpecificErrorCode = arg.move();
    __isset.appSpecificErrorCode = true;
  }

  McVersionReply(McVersionReply&&) = default;

  McVersionReply(const McVersionReply&) = default;

  McVersionReply& operator=(McVersionReply&&) = default;

  McVersionReply& operator=(const McVersionReply&) = default;
  void __clear();

  virtual ~McVersionReply() throw() {}

  int16_t result;
   ::facebook::memcache::cpp2::IOBuf value;
  std::string message;
  int16_t appSpecificErrorCode;

  struct __isset {
    void __clear() {
      result = false;
      value = false;
      message = false;
      appSpecificErrorCode = false;
    }

    bool result = false;
    bool value = false;
    bool message = false;
    bool appSpecificErrorCode = false;
  } __isset;
  bool operator==(const McVersionReply& rhs) const;
  bool operator < (const McVersionReply& rhs) const;

  int16_t get_result() const {
    return result;
  }

  int16_t& set_result(int16_t result_) {
    result = result_;
    __isset.result = true;
    return result;
  }

  const  ::facebook::memcache::cpp2::IOBuf* get_value() const& {
    return __isset.value ? std::addressof(value) : nullptr;
  }

   ::facebook::memcache::cpp2::IOBuf* get_value() & {
    return __isset.value ? std::addressof(value) : nullptr;
  }
   ::facebook::memcache::cpp2::IOBuf* get_value() && = delete;

  template <typename T_McVersionReply_value_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_value(T_McVersionReply_value_struct_setter&& value_) {
    value = std::forward<T_McVersionReply_value_struct_setter>(value_);
    __isset.value = true;
    return value;
  }

  const std::string* get_message() const& {
    return __isset.message ? std::addressof(message) : nullptr;
  }

  std::string* get_message() & {
    return __isset.message ? std::addressof(message) : nullptr;
  }
  std::string* get_message() && = delete;

  template <typename T_McVersionReply_message_struct_setter>
  std::string& set_message(T_McVersionReply_message_struct_setter&& message_) {
    message = std::forward<T_McVersionReply_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  const int16_t* get_appSpecificErrorCode() const& {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }

  int16_t* get_appSpecificErrorCode() & {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }
  int16_t* get_appSpecificErrorCode() && = delete;

  int16_t& set_appSpecificErrorCode(int16_t appSpecificErrorCode_) {
    appSpecificErrorCode = appSpecificErrorCode_;
    __isset.appSpecificErrorCode = true;
    return appSpecificErrorCode;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McVersionReply& a, McVersionReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McVersionReply>::clear( ::facebook::memcache::cpp2::McVersionReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McVersionReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McVersionReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McVersionReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McVersionReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McVersionReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McVersionReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McVersionReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McVersionReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McVersionReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McAppendRequest : private boost::totally_ordered<McAppendRequest> {
 public:

  McAppendRequest() :
      exptime(0),
      flags(0) {}
  // FragileConstructor for use in initialization lists only

  McAppendRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg, int32_t exptime__arg, int64_t flags__arg,  ::facebook::memcache::cpp2::IOBuf value__arg) :
      key(std::move(key__arg)),
      exptime(std::move(exptime__arg)),
      flags(std::move(flags__arg)),
      value(std::move(value__arg)) {
    __isset.key = true;
    __isset.exptime = true;
    __isset.flags = true;
    __isset.value = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McAppendRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McAppendRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    key = arg.move();
    __isset.key = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McAppendRequest(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McAppendRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    exptime = arg.move();
    __isset.exptime = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McAppendRequest(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McAppendRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    flags = arg.move();
    __isset.flags = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McAppendRequest(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McAppendRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    value = arg.move();
    __isset.value = true;
  }

  McAppendRequest(McAppendRequest&&) = default;

  McAppendRequest(const McAppendRequest&) = default;

  McAppendRequest& operator=(McAppendRequest&&) = default;

  McAppendRequest& operator=(const McAppendRequest&) = default;
  void __clear();

  virtual ~McAppendRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;
  int32_t exptime;
  int64_t flags;
   ::facebook::memcache::cpp2::IOBuf value;

  struct __isset {
    void __clear() {
      key = false;
      exptime = false;
      flags = false;
      value = false;
    }

    bool key = false;
    bool exptime = false;
    bool flags = false;
    bool value = false;
  } __isset;
  bool operator==(const McAppendRequest& rhs) const;
  bool operator < (const McAppendRequest& rhs) const;

  const  ::facebook::memcache::cpp2::IOBuf& get_key() const& {
    return key;
  }

   ::facebook::memcache::cpp2::IOBuf get_key() && {
    return std::move(key);
  }

  template <typename T_McAppendRequest_key_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_key(T_McAppendRequest_key_struct_setter&& key_) {
    key = std::forward<T_McAppendRequest_key_struct_setter>(key_);
    __isset.key = true;
    return key;
  }

  int32_t get_exptime() const {
    return exptime;
  }

  int32_t& set_exptime(int32_t exptime_) {
    exptime = exptime_;
    __isset.exptime = true;
    return exptime;
  }

  int64_t get_flags() const {
    return flags;
  }

  int64_t& set_flags(int64_t flags_) {
    flags = flags_;
    __isset.flags = true;
    return flags;
  }

  const  ::facebook::memcache::cpp2::IOBuf& get_value() const& {
    return value;
  }

   ::facebook::memcache::cpp2::IOBuf get_value() && {
    return std::move(value);
  }

  template <typename T_McAppendRequest_value_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_value(T_McAppendRequest_value_struct_setter&& value_) {
    value = std::forward<T_McAppendRequest_value_struct_setter>(value_);
    __isset.value = true;
    return value;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McAppendRequest& a, McAppendRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McAppendRequest>::clear( ::facebook::memcache::cpp2::McAppendRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McAppendRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAppendRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McAppendRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAppendRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McAppendRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAppendRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McAppendRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAppendRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McAppendRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McAppendReply : private boost::totally_ordered<McAppendReply> {
 public:

  McAppendReply() :
      result(0),
      appSpecificErrorCode(0) {}
  // FragileConstructor for use in initialization lists only

  McAppendReply(apache::thrift::FragileConstructor, int16_t result__arg, std::string message__arg, int16_t appSpecificErrorCode__arg) :
      result(std::move(result__arg)),
      message(std::move(message__arg)),
      appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
    __isset.result = true;
    __isset.message = true;
    __isset.appSpecificErrorCode = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McAppendReply(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McAppendReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    result = arg.move();
    __isset.result = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McAppendReply(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McAppendReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    message = arg.move();
    __isset.message = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McAppendReply(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McAppendReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    appSpecificErrorCode = arg.move();
    __isset.appSpecificErrorCode = true;
  }

  McAppendReply(McAppendReply&&) = default;

  McAppendReply(const McAppendReply&) = default;

  McAppendReply& operator=(McAppendReply&&) = default;

  McAppendReply& operator=(const McAppendReply&) = default;
  void __clear();

  virtual ~McAppendReply() throw() {}

  int16_t result;
  std::string message;
  int16_t appSpecificErrorCode;

  struct __isset {
    void __clear() {
      result = false;
      message = false;
      appSpecificErrorCode = false;
    }

    bool result = false;
    bool message = false;
    bool appSpecificErrorCode = false;
  } __isset;
  bool operator==(const McAppendReply& rhs) const;
  bool operator < (const McAppendReply& rhs) const;

  int16_t get_result() const {
    return result;
  }

  int16_t& set_result(int16_t result_) {
    result = result_;
    __isset.result = true;
    return result;
  }

  const std::string* get_message() const& {
    return __isset.message ? std::addressof(message) : nullptr;
  }

  std::string* get_message() & {
    return __isset.message ? std::addressof(message) : nullptr;
  }
  std::string* get_message() && = delete;

  template <typename T_McAppendReply_message_struct_setter>
  std::string& set_message(T_McAppendReply_message_struct_setter&& message_) {
    message = std::forward<T_McAppendReply_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  const int16_t* get_appSpecificErrorCode() const& {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }

  int16_t* get_appSpecificErrorCode() & {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }
  int16_t* get_appSpecificErrorCode() && = delete;

  int16_t& set_appSpecificErrorCode(int16_t appSpecificErrorCode_) {
    appSpecificErrorCode = appSpecificErrorCode_;
    __isset.appSpecificErrorCode = true;
    return appSpecificErrorCode;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McAppendReply& a, McAppendReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McAppendReply>::clear( ::facebook::memcache::cpp2::McAppendReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McAppendReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAppendReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McAppendReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAppendReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McAppendReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAppendReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McAppendReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAppendReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McAppendReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McPrependRequest : private boost::totally_ordered<McPrependRequest> {
 public:

  McPrependRequest() :
      exptime(0),
      flags(0) {}
  // FragileConstructor for use in initialization lists only

  McPrependRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg, int32_t exptime__arg, int64_t flags__arg,  ::facebook::memcache::cpp2::IOBuf value__arg) :
      key(std::move(key__arg)),
      exptime(std::move(exptime__arg)),
      flags(std::move(flags__arg)),
      value(std::move(value__arg)) {
    __isset.key = true;
    __isset.exptime = true;
    __isset.flags = true;
    __isset.value = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McPrependRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McPrependRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    key = arg.move();
    __isset.key = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McPrependRequest(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McPrependRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    exptime = arg.move();
    __isset.exptime = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McPrependRequest(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McPrependRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    flags = arg.move();
    __isset.flags = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McPrependRequest(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McPrependRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    value = arg.move();
    __isset.value = true;
  }

  McPrependRequest(McPrependRequest&&) = default;

  McPrependRequest(const McPrependRequest&) = default;

  McPrependRequest& operator=(McPrependRequest&&) = default;

  McPrependRequest& operator=(const McPrependRequest&) = default;
  void __clear();

  virtual ~McPrependRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;
  int32_t exptime;
  int64_t flags;
   ::facebook::memcache::cpp2::IOBuf value;

  struct __isset {
    void __clear() {
      key = false;
      exptime = false;
      flags = false;
      value = false;
    }

    bool key = false;
    bool exptime = false;
    bool flags = false;
    bool value = false;
  } __isset;
  bool operator==(const McPrependRequest& rhs) const;
  bool operator < (const McPrependRequest& rhs) const;

  const  ::facebook::memcache::cpp2::IOBuf& get_key() const& {
    return key;
  }

   ::facebook::memcache::cpp2::IOBuf get_key() && {
    return std::move(key);
  }

  template <typename T_McPrependRequest_key_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_key(T_McPrependRequest_key_struct_setter&& key_) {
    key = std::forward<T_McPrependRequest_key_struct_setter>(key_);
    __isset.key = true;
    return key;
  }

  int32_t get_exptime() const {
    return exptime;
  }

  int32_t& set_exptime(int32_t exptime_) {
    exptime = exptime_;
    __isset.exptime = true;
    return exptime;
  }

  int64_t get_flags() const {
    return flags;
  }

  int64_t& set_flags(int64_t flags_) {
    flags = flags_;
    __isset.flags = true;
    return flags;
  }

  const  ::facebook::memcache::cpp2::IOBuf& get_value() const& {
    return value;
  }

   ::facebook::memcache::cpp2::IOBuf get_value() && {
    return std::move(value);
  }

  template <typename T_McPrependRequest_value_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_value(T_McPrependRequest_value_struct_setter&& value_) {
    value = std::forward<T_McPrependRequest_value_struct_setter>(value_);
    __isset.value = true;
    return value;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McPrependRequest& a, McPrependRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McPrependRequest>::clear( ::facebook::memcache::cpp2::McPrependRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McPrependRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McPrependRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McPrependRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McPrependRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McPrependRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McPrependRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McPrependRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McPrependRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McPrependRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McPrependReply : private boost::totally_ordered<McPrependReply> {
 public:

  McPrependReply() :
      result(0),
      appSpecificErrorCode(0) {}
  // FragileConstructor for use in initialization lists only

  McPrependReply(apache::thrift::FragileConstructor, int16_t result__arg, std::string message__arg, int16_t appSpecificErrorCode__arg) :
      result(std::move(result__arg)),
      message(std::move(message__arg)),
      appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
    __isset.result = true;
    __isset.message = true;
    __isset.appSpecificErrorCode = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McPrependReply(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McPrependReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    result = arg.move();
    __isset.result = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McPrependReply(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McPrependReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    message = arg.move();
    __isset.message = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McPrependReply(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McPrependReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    appSpecificErrorCode = arg.move();
    __isset.appSpecificErrorCode = true;
  }

  McPrependReply(McPrependReply&&) = default;

  McPrependReply(const McPrependReply&) = default;

  McPrependReply& operator=(McPrependReply&&) = default;

  McPrependReply& operator=(const McPrependReply&) = default;
  void __clear();

  virtual ~McPrependReply() throw() {}

  int16_t result;
  std::string message;
  int16_t appSpecificErrorCode;

  struct __isset {
    void __clear() {
      result = false;
      message = false;
      appSpecificErrorCode = false;
    }

    bool result = false;
    bool message = false;
    bool appSpecificErrorCode = false;
  } __isset;
  bool operator==(const McPrependReply& rhs) const;
  bool operator < (const McPrependReply& rhs) const;

  int16_t get_result() const {
    return result;
  }

  int16_t& set_result(int16_t result_) {
    result = result_;
    __isset.result = true;
    return result;
  }

  const std::string* get_message() const& {
    return __isset.message ? std::addressof(message) : nullptr;
  }

  std::string* get_message() & {
    return __isset.message ? std::addressof(message) : nullptr;
  }
  std::string* get_message() && = delete;

  template <typename T_McPrependReply_message_struct_setter>
  std::string& set_message(T_McPrependReply_message_struct_setter&& message_) {
    message = std::forward<T_McPrependReply_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  const int16_t* get_appSpecificErrorCode() const& {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }

  int16_t* get_appSpecificErrorCode() & {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }
  int16_t* get_appSpecificErrorCode() && = delete;

  int16_t& set_appSpecificErrorCode(int16_t appSpecificErrorCode_) {
    appSpecificErrorCode = appSpecificErrorCode_;
    __isset.appSpecificErrorCode = true;
    return appSpecificErrorCode;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McPrependReply& a, McPrependReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McPrependReply>::clear( ::facebook::memcache::cpp2::McPrependReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McPrependReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McPrependReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McPrependReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McPrependReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McPrependReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McPrependReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McPrependReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McPrependReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McPrependReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McTouchRequest : private boost::totally_ordered<McTouchRequest> {
 public:

  McTouchRequest() :
      exptime(0) {}
  // FragileConstructor for use in initialization lists only

  McTouchRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg, int32_t exptime__arg) :
      key(std::move(key__arg)),
      exptime(std::move(exptime__arg)) {
    __isset.key = true;
    __isset.exptime = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McTouchRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McTouchRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    key = arg.move();
    __isset.key = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McTouchRequest(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McTouchRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    exptime = arg.move();
    __isset.exptime = true;
  }

  McTouchRequest(McTouchRequest&&) = default;

  McTouchRequest(const McTouchRequest&) = default;

  McTouchRequest& operator=(McTouchRequest&&) = default;

  McTouchRequest& operator=(const McTouchRequest&) = default;
  void __clear();

  virtual ~McTouchRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;
  int32_t exptime;

  struct __isset {
    void __clear() {
      key = false;
      exptime = false;
    }

    bool key = false;
    bool exptime = false;
  } __isset;
  bool operator==(const McTouchRequest& rhs) const;
  bool operator < (const McTouchRequest& rhs) const;

  const  ::facebook::memcache::cpp2::IOBuf& get_key() const& {
    return key;
  }

   ::facebook::memcache::cpp2::IOBuf get_key() && {
    return std::move(key);
  }

  template <typename T_McTouchRequest_key_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_key(T_McTouchRequest_key_struct_setter&& key_) {
    key = std::forward<T_McTouchRequest_key_struct_setter>(key_);
    __isset.key = true;
    return key;
  }

  int32_t get_exptime() const {
    return exptime;
  }

  int32_t& set_exptime(int32_t exptime_) {
    exptime = exptime_;
    __isset.exptime = true;
    return exptime;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McTouchRequest& a, McTouchRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McTouchRequest>::clear( ::facebook::memcache::cpp2::McTouchRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McTouchRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McTouchRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McTouchRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McTouchRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McTouchRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McTouchRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McTouchRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McTouchRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McTouchRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McTouchReply : private boost::totally_ordered<McTouchReply> {
 public:

  McTouchReply() :
      result(0),
      appSpecificErrorCode(0) {}
  // FragileConstructor for use in initialization lists only

  McTouchReply(apache::thrift::FragileConstructor, int16_t result__arg, std::string message__arg, int16_t appSpecificErrorCode__arg) :
      result(std::move(result__arg)),
      message(std::move(message__arg)),
      appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
    __isset.result = true;
    __isset.message = true;
    __isset.appSpecificErrorCode = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McTouchReply(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McTouchReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    result = arg.move();
    __isset.result = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McTouchReply(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McTouchReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    message = arg.move();
    __isset.message = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McTouchReply(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McTouchReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    appSpecificErrorCode = arg.move();
    __isset.appSpecificErrorCode = true;
  }

  McTouchReply(McTouchReply&&) = default;

  McTouchReply(const McTouchReply&) = default;

  McTouchReply& operator=(McTouchReply&&) = default;

  McTouchReply& operator=(const McTouchReply&) = default;
  void __clear();

  virtual ~McTouchReply() throw() {}

  int16_t result;
  std::string message;
  int16_t appSpecificErrorCode;

  struct __isset {
    void __clear() {
      result = false;
      message = false;
      appSpecificErrorCode = false;
    }

    bool result = false;
    bool message = false;
    bool appSpecificErrorCode = false;
  } __isset;
  bool operator==(const McTouchReply& rhs) const;
  bool operator < (const McTouchReply& rhs) const;

  int16_t get_result() const {
    return result;
  }

  int16_t& set_result(int16_t result_) {
    result = result_;
    __isset.result = true;
    return result;
  }

  const std::string* get_message() const& {
    return __isset.message ? std::addressof(message) : nullptr;
  }

  std::string* get_message() & {
    return __isset.message ? std::addressof(message) : nullptr;
  }
  std::string* get_message() && = delete;

  template <typename T_McTouchReply_message_struct_setter>
  std::string& set_message(T_McTouchReply_message_struct_setter&& message_) {
    message = std::forward<T_McTouchReply_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  const int16_t* get_appSpecificErrorCode() const& {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }

  int16_t* get_appSpecificErrorCode() & {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }
  int16_t* get_appSpecificErrorCode() && = delete;

  int16_t& set_appSpecificErrorCode(int16_t appSpecificErrorCode_) {
    appSpecificErrorCode = appSpecificErrorCode_;
    __isset.appSpecificErrorCode = true;
    return appSpecificErrorCode;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McTouchReply& a, McTouchReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McTouchReply>::clear( ::facebook::memcache::cpp2::McTouchReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McTouchReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McTouchReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McTouchReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McTouchReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McTouchReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McTouchReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McTouchReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McTouchReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McTouchReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McStatsRequest : private boost::totally_ordered<McStatsRequest> {
 public:

  McStatsRequest() {}
  // FragileConstructor for use in initialization lists only

  McStatsRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg) :
      key(std::move(key__arg)) {
    __isset.key = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McStatsRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McStatsRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    key = arg.move();
    __isset.key = true;
  }

  McStatsRequest(McStatsRequest&&) = default;

  McStatsRequest(const McStatsRequest&) = default;

  McStatsRequest& operator=(McStatsRequest&&) = default;

  McStatsRequest& operator=(const McStatsRequest&) = default;
  void __clear();

  virtual ~McStatsRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;

  struct __isset {
    void __clear() {
      key = false;
    }

    bool key = false;
  } __isset;
  bool operator==(const McStatsRequest& rhs) const;
  bool operator < (const McStatsRequest& rhs) const;

  const  ::facebook::memcache::cpp2::IOBuf& get_key() const& {
    return key;
  }

   ::facebook::memcache::cpp2::IOBuf get_key() && {
    return std::move(key);
  }

  template <typename T_McStatsRequest_key_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_key(T_McStatsRequest_key_struct_setter&& key_) {
    key = std::forward<T_McStatsRequest_key_struct_setter>(key_);
    __isset.key = true;
    return key;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McStatsRequest& a, McStatsRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McStatsRequest>::clear( ::facebook::memcache::cpp2::McStatsRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McStatsRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McStatsRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McStatsRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McStatsRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McStatsRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McStatsRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McStatsRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McStatsRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McStatsRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McStatsReply : private boost::totally_ordered<McStatsReply> {
 public:

  McStatsReply() :
      result(0),
      appSpecificErrorCode(0) {}
  // FragileConstructor for use in initialization lists only

  McStatsReply(apache::thrift::FragileConstructor, int16_t result__arg, std::string message__arg, std::vector<std::string> stats__arg, int16_t appSpecificErrorCode__arg) :
      result(std::move(result__arg)),
      message(std::move(message__arg)),
      stats(std::move(stats__arg)),
      appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
    __isset.result = true;
    __isset.message = true;
    __isset.stats = true;
    __isset.appSpecificErrorCode = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McStatsReply(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McStatsReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    result = arg.move();
    __isset.result = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McStatsReply(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McStatsReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    message = arg.move();
    __isset.message = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McStatsReply(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McStatsReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    stats = arg.move();
    __isset.stats = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McStatsReply(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McStatsReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    appSpecificErrorCode = arg.move();
    __isset.appSpecificErrorCode = true;
  }

  McStatsReply(McStatsReply&&) = default;

  McStatsReply(const McStatsReply&) = default;

  McStatsReply& operator=(McStatsReply&&) = default;

  McStatsReply& operator=(const McStatsReply&) = default;
  void __clear();

  virtual ~McStatsReply() throw() {}

  int16_t result;
  std::string message;
  std::vector<std::string> stats;
  int16_t appSpecificErrorCode;

  struct __isset {
    void __clear() {
      result = false;
      message = false;
      stats = false;
      appSpecificErrorCode = false;
    }

    bool result = false;
    bool message = false;
    bool stats = false;
    bool appSpecificErrorCode = false;
  } __isset;
  bool operator==(const McStatsReply& rhs) const;
  bool operator < (const McStatsReply& rhs) const;

  int16_t get_result() const {
    return result;
  }

  int16_t& set_result(int16_t result_) {
    result = result_;
    __isset.result = true;
    return result;
  }

  const std::string* get_message() const& {
    return __isset.message ? std::addressof(message) : nullptr;
  }

  std::string* get_message() & {
    return __isset.message ? std::addressof(message) : nullptr;
  }
  std::string* get_message() && = delete;

  template <typename T_McStatsReply_message_struct_setter>
  std::string& set_message(T_McStatsReply_message_struct_setter&& message_) {
    message = std::forward<T_McStatsReply_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }
  const std::vector<std::string>* get_stats() const&;
  std::vector<std::string>* get_stats() &;
  std::vector<std::string>* get_stats() && = delete;
  template <typename T_McStatsReply_stats_struct_setter>
  std::vector<std::string>& set_stats(T_McStatsReply_stats_struct_setter&& stats_);

  const int16_t* get_appSpecificErrorCode() const& {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }

  int16_t* get_appSpecificErrorCode() & {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }
  int16_t* get_appSpecificErrorCode() && = delete;

  int16_t& set_appSpecificErrorCode(int16_t appSpecificErrorCode_) {
    appSpecificErrorCode = appSpecificErrorCode_;
    __isset.appSpecificErrorCode = true;
    return appSpecificErrorCode;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McStatsReply& a, McStatsReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McStatsReply>::clear( ::facebook::memcache::cpp2::McStatsReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McStatsReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McStatsReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McStatsReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McStatsReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McStatsReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McStatsReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McStatsReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McStatsReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McStatsReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McShutdownRequest : private boost::totally_ordered<McShutdownRequest> {
 public:

  McShutdownRequest() {}
  // FragileConstructor for use in initialization lists only

  McShutdownRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg) :
      key(std::move(key__arg)) {
    __isset.key = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McShutdownRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McShutdownRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    key = arg.move();
    __isset.key = true;
  }

  McShutdownRequest(McShutdownRequest&&) = default;

  McShutdownRequest(const McShutdownRequest&) = default;

  McShutdownRequest& operator=(McShutdownRequest&&) = default;

  McShutdownRequest& operator=(const McShutdownRequest&) = default;
  void __clear();

  virtual ~McShutdownRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;

  struct __isset {
    void __clear() {
      key = false;
    }

    bool key = false;
  } __isset;
  bool operator==(const McShutdownRequest& rhs) const;
  bool operator < (const McShutdownRequest& rhs) const;

  const  ::facebook::memcache::cpp2::IOBuf& get_key() const& {
    return key;
  }

   ::facebook::memcache::cpp2::IOBuf get_key() && {
    return std::move(key);
  }

  template <typename T_McShutdownRequest_key_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_key(T_McShutdownRequest_key_struct_setter&& key_) {
    key = std::forward<T_McShutdownRequest_key_struct_setter>(key_);
    __isset.key = true;
    return key;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McShutdownRequest& a, McShutdownRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McShutdownRequest>::clear( ::facebook::memcache::cpp2::McShutdownRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McShutdownRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McShutdownRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McShutdownRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McShutdownRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McShutdownRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McShutdownRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McShutdownRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McShutdownRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McShutdownRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McShutdownReply : private boost::totally_ordered<McShutdownReply> {
 public:

  McShutdownReply() :
      result(0),
      appSpecificErrorCode(0) {}
  // FragileConstructor for use in initialization lists only

  McShutdownReply(apache::thrift::FragileConstructor, int16_t result__arg, std::string message__arg, int16_t appSpecificErrorCode__arg) :
      result(std::move(result__arg)),
      message(std::move(message__arg)),
      appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
    __isset.result = true;
    __isset.message = true;
    __isset.appSpecificErrorCode = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McShutdownReply(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McShutdownReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    result = arg.move();
    __isset.result = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McShutdownReply(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McShutdownReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    message = arg.move();
    __isset.message = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McShutdownReply(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McShutdownReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    appSpecificErrorCode = arg.move();
    __isset.appSpecificErrorCode = true;
  }

  McShutdownReply(McShutdownReply&&) = default;

  McShutdownReply(const McShutdownReply&) = default;

  McShutdownReply& operator=(McShutdownReply&&) = default;

  McShutdownReply& operator=(const McShutdownReply&) = default;
  void __clear();

  virtual ~McShutdownReply() throw() {}

  int16_t result;
  std::string message;
  int16_t appSpecificErrorCode;

  struct __isset {
    void __clear() {
      result = false;
      message = false;
      appSpecificErrorCode = false;
    }

    bool result = false;
    bool message = false;
    bool appSpecificErrorCode = false;
  } __isset;
  bool operator==(const McShutdownReply& rhs) const;
  bool operator < (const McShutdownReply& rhs) const;

  int16_t get_result() const {
    return result;
  }

  int16_t& set_result(int16_t result_) {
    result = result_;
    __isset.result = true;
    return result;
  }

  const std::string* get_message() const& {
    return __isset.message ? std::addressof(message) : nullptr;
  }

  std::string* get_message() & {
    return __isset.message ? std::addressof(message) : nullptr;
  }
  std::string* get_message() && = delete;

  template <typename T_McShutdownReply_message_struct_setter>
  std::string& set_message(T_McShutdownReply_message_struct_setter&& message_) {
    message = std::forward<T_McShutdownReply_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  const int16_t* get_appSpecificErrorCode() const& {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }

  int16_t* get_appSpecificErrorCode() & {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }
  int16_t* get_appSpecificErrorCode() && = delete;

  int16_t& set_appSpecificErrorCode(int16_t appSpecificErrorCode_) {
    appSpecificErrorCode = appSpecificErrorCode_;
    __isset.appSpecificErrorCode = true;
    return appSpecificErrorCode;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McShutdownReply& a, McShutdownReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McShutdownReply>::clear( ::facebook::memcache::cpp2::McShutdownReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McShutdownReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McShutdownReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McShutdownReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McShutdownReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McShutdownReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McShutdownReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McShutdownReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McShutdownReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McShutdownReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McQuitRequest : private boost::totally_ordered<McQuitRequest> {
 public:

  McQuitRequest() {}
  // FragileConstructor for use in initialization lists only

  McQuitRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg) :
      key(std::move(key__arg)) {
    __isset.key = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McQuitRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McQuitRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    key = arg.move();
    __isset.key = true;
  }

  McQuitRequest(McQuitRequest&&) = default;

  McQuitRequest(const McQuitRequest&) = default;

  McQuitRequest& operator=(McQuitRequest&&) = default;

  McQuitRequest& operator=(const McQuitRequest&) = default;
  void __clear();

  virtual ~McQuitRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;

  struct __isset {
    void __clear() {
      key = false;
    }

    bool key = false;
  } __isset;
  bool operator==(const McQuitRequest& rhs) const;
  bool operator < (const McQuitRequest& rhs) const;

  const  ::facebook::memcache::cpp2::IOBuf& get_key() const& {
    return key;
  }

   ::facebook::memcache::cpp2::IOBuf get_key() && {
    return std::move(key);
  }

  template <typename T_McQuitRequest_key_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_key(T_McQuitRequest_key_struct_setter&& key_) {
    key = std::forward<T_McQuitRequest_key_struct_setter>(key_);
    __isset.key = true;
    return key;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McQuitRequest& a, McQuitRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McQuitRequest>::clear( ::facebook::memcache::cpp2::McQuitRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McQuitRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McQuitRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McQuitRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McQuitRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McQuitRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McQuitRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McQuitRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McQuitRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McQuitRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McQuitReply : private boost::totally_ordered<McQuitReply> {
 public:

  McQuitReply() :
      result(0),
      appSpecificErrorCode(0) {}
  // FragileConstructor for use in initialization lists only

  McQuitReply(apache::thrift::FragileConstructor, int16_t result__arg, std::string message__arg, int16_t appSpecificErrorCode__arg) :
      result(std::move(result__arg)),
      message(std::move(message__arg)),
      appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
    __isset.result = true;
    __isset.message = true;
    __isset.appSpecificErrorCode = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McQuitReply(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McQuitReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    result = arg.move();
    __isset.result = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McQuitReply(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McQuitReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    message = arg.move();
    __isset.message = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McQuitReply(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McQuitReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    appSpecificErrorCode = arg.move();
    __isset.appSpecificErrorCode = true;
  }

  McQuitReply(McQuitReply&&) = default;

  McQuitReply(const McQuitReply&) = default;

  McQuitReply& operator=(McQuitReply&&) = default;

  McQuitReply& operator=(const McQuitReply&) = default;
  void __clear();

  virtual ~McQuitReply() throw() {}

  int16_t result;
  std::string message;
  int16_t appSpecificErrorCode;

  struct __isset {
    void __clear() {
      result = false;
      message = false;
      appSpecificErrorCode = false;
    }

    bool result = false;
    bool message = false;
    bool appSpecificErrorCode = false;
  } __isset;
  bool operator==(const McQuitReply& rhs) const;
  bool operator < (const McQuitReply& rhs) const;

  int16_t get_result() const {
    return result;
  }

  int16_t& set_result(int16_t result_) {
    result = result_;
    __isset.result = true;
    return result;
  }

  const std::string* get_message() const& {
    return __isset.message ? std::addressof(message) : nullptr;
  }

  std::string* get_message() & {
    return __isset.message ? std::addressof(message) : nullptr;
  }
  std::string* get_message() && = delete;

  template <typename T_McQuitReply_message_struct_setter>
  std::string& set_message(T_McQuitReply_message_struct_setter&& message_) {
    message = std::forward<T_McQuitReply_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  const int16_t* get_appSpecificErrorCode() const& {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }

  int16_t* get_appSpecificErrorCode() & {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }
  int16_t* get_appSpecificErrorCode() && = delete;

  int16_t& set_appSpecificErrorCode(int16_t appSpecificErrorCode_) {
    appSpecificErrorCode = appSpecificErrorCode_;
    __isset.appSpecificErrorCode = true;
    return appSpecificErrorCode;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McQuitReply& a, McQuitReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McQuitReply>::clear( ::facebook::memcache::cpp2::McQuitReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McQuitReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McQuitReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McQuitReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McQuitReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McQuitReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McQuitReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McQuitReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McQuitReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McQuitReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McExecRequest : private boost::totally_ordered<McExecRequest> {
 public:

  McExecRequest() {}
  // FragileConstructor for use in initialization lists only

  McExecRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg) :
      key(std::move(key__arg)) {
    __isset.key = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McExecRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McExecRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    key = arg.move();
    __isset.key = true;
  }

  McExecRequest(McExecRequest&&) = default;

  McExecRequest(const McExecRequest&) = default;

  McExecRequest& operator=(McExecRequest&&) = default;

  McExecRequest& operator=(const McExecRequest&) = default;
  void __clear();

  virtual ~McExecRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;

  struct __isset {
    void __clear() {
      key = false;
    }

    bool key = false;
  } __isset;
  bool operator==(const McExecRequest& rhs) const;
  bool operator < (const McExecRequest& rhs) const;

  const  ::facebook::memcache::cpp2::IOBuf& get_key() const& {
    return key;
  }

   ::facebook::memcache::cpp2::IOBuf get_key() && {
    return std::move(key);
  }

  template <typename T_McExecRequest_key_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_key(T_McExecRequest_key_struct_setter&& key_) {
    key = std::forward<T_McExecRequest_key_struct_setter>(key_);
    __isset.key = true;
    return key;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McExecRequest& a, McExecRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McExecRequest>::clear( ::facebook::memcache::cpp2::McExecRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McExecRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McExecRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McExecRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McExecRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McExecRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McExecRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McExecRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McExecRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McExecRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McExecReply : private boost::totally_ordered<McExecReply> {
 public:

  McExecReply() :
      result(0),
      appSpecificErrorCode(0) {}
  // FragileConstructor for use in initialization lists only

  McExecReply(apache::thrift::FragileConstructor, int16_t result__arg, std::string response__arg, std::string message__arg, int16_t appSpecificErrorCode__arg) :
      result(std::move(result__arg)),
      response(std::move(response__arg)),
      message(std::move(message__arg)),
      appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
    __isset.result = true;
    __isset.response = true;
    __isset.message = true;
    __isset.appSpecificErrorCode = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McExecReply(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McExecReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    result = arg.move();
    __isset.result = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McExecReply(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McExecReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    response = arg.move();
    __isset.response = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McExecReply(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McExecReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    message = arg.move();
    __isset.message = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McExecReply(::apache::thrift::detail::argument_wrapper<4, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McExecReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    appSpecificErrorCode = arg.move();
    __isset.appSpecificErrorCode = true;
  }

  McExecReply(McExecReply&&) = default;

  McExecReply(const McExecReply&) = default;

  McExecReply& operator=(McExecReply&&) = default;

  McExecReply& operator=(const McExecReply&) = default;
  void __clear();

  virtual ~McExecReply() throw() {}

  int16_t result;
  std::string response;
  std::string message;
  int16_t appSpecificErrorCode;

  struct __isset {
    void __clear() {
      result = false;
      response = false;
      message = false;
      appSpecificErrorCode = false;
    }

    bool result = false;
    bool response = false;
    bool message = false;
    bool appSpecificErrorCode = false;
  } __isset;
  bool operator==(const McExecReply& rhs) const;
  bool operator < (const McExecReply& rhs) const;

  int16_t get_result() const {
    return result;
  }

  int16_t& set_result(int16_t result_) {
    result = result_;
    __isset.result = true;
    return result;
  }

  const std::string* get_response() const& {
    return __isset.response ? std::addressof(response) : nullptr;
  }

  std::string* get_response() & {
    return __isset.response ? std::addressof(response) : nullptr;
  }
  std::string* get_response() && = delete;

  template <typename T_McExecReply_response_struct_setter>
  std::string& set_response(T_McExecReply_response_struct_setter&& response_) {
    response = std::forward<T_McExecReply_response_struct_setter>(response_);
    __isset.response = true;
    return response;
  }

  const std::string* get_message() const& {
    return __isset.message ? std::addressof(message) : nullptr;
  }

  std::string* get_message() & {
    return __isset.message ? std::addressof(message) : nullptr;
  }
  std::string* get_message() && = delete;

  template <typename T_McExecReply_message_struct_setter>
  std::string& set_message(T_McExecReply_message_struct_setter&& message_) {
    message = std::forward<T_McExecReply_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  const int16_t* get_appSpecificErrorCode() const& {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }

  int16_t* get_appSpecificErrorCode() & {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }
  int16_t* get_appSpecificErrorCode() && = delete;

  int16_t& set_appSpecificErrorCode(int16_t appSpecificErrorCode_) {
    appSpecificErrorCode = appSpecificErrorCode_;
    __isset.appSpecificErrorCode = true;
    return appSpecificErrorCode;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McExecReply& a, McExecReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McExecReply>::clear( ::facebook::memcache::cpp2::McExecReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McExecReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McExecReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McExecReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McExecReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McExecReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McExecReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McExecReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McExecReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McExecReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McFlushReRequest : private boost::totally_ordered<McFlushReRequest> {
 public:

  McFlushReRequest() {}
  // FragileConstructor for use in initialization lists only

  McFlushReRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg) :
      key(std::move(key__arg)) {
    __isset.key = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McFlushReRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McFlushReRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    key = arg.move();
    __isset.key = true;
  }

  McFlushReRequest(McFlushReRequest&&) = default;

  McFlushReRequest(const McFlushReRequest&) = default;

  McFlushReRequest& operator=(McFlushReRequest&&) = default;

  McFlushReRequest& operator=(const McFlushReRequest&) = default;
  void __clear();

  virtual ~McFlushReRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;

  struct __isset {
    void __clear() {
      key = false;
    }

    bool key = false;
  } __isset;
  bool operator==(const McFlushReRequest& rhs) const;
  bool operator < (const McFlushReRequest& rhs) const;

  const  ::facebook::memcache::cpp2::IOBuf& get_key() const& {
    return key;
  }

   ::facebook::memcache::cpp2::IOBuf get_key() && {
    return std::move(key);
  }

  template <typename T_McFlushReRequest_key_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_key(T_McFlushReRequest_key_struct_setter&& key_) {
    key = std::forward<T_McFlushReRequest_key_struct_setter>(key_);
    __isset.key = true;
    return key;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McFlushReRequest& a, McFlushReRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McFlushReRequest>::clear( ::facebook::memcache::cpp2::McFlushReRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McFlushReRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McFlushReRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McFlushReRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McFlushReRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McFlushReRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McFlushReRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McFlushReRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McFlushReRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McFlushReRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McFlushReReply : private boost::totally_ordered<McFlushReReply> {
 public:

  McFlushReReply() :
      result(0),
      appSpecificErrorCode(0) {}
  // FragileConstructor for use in initialization lists only

  McFlushReReply(apache::thrift::FragileConstructor, int16_t result__arg, std::string message__arg, int16_t appSpecificErrorCode__arg) :
      result(std::move(result__arg)),
      message(std::move(message__arg)),
      appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
    __isset.result = true;
    __isset.message = true;
    __isset.appSpecificErrorCode = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McFlushReReply(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McFlushReReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    result = arg.move();
    __isset.result = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McFlushReReply(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McFlushReReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    message = arg.move();
    __isset.message = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McFlushReReply(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McFlushReReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    appSpecificErrorCode = arg.move();
    __isset.appSpecificErrorCode = true;
  }

  McFlushReReply(McFlushReReply&&) = default;

  McFlushReReply(const McFlushReReply&) = default;

  McFlushReReply& operator=(McFlushReReply&&) = default;

  McFlushReReply& operator=(const McFlushReReply&) = default;
  void __clear();

  virtual ~McFlushReReply() throw() {}

  int16_t result;
  std::string message;
  int16_t appSpecificErrorCode;

  struct __isset {
    void __clear() {
      result = false;
      message = false;
      appSpecificErrorCode = false;
    }

    bool result = false;
    bool message = false;
    bool appSpecificErrorCode = false;
  } __isset;
  bool operator==(const McFlushReReply& rhs) const;
  bool operator < (const McFlushReReply& rhs) const;

  int16_t get_result() const {
    return result;
  }

  int16_t& set_result(int16_t result_) {
    result = result_;
    __isset.result = true;
    return result;
  }

  const std::string* get_message() const& {
    return __isset.message ? std::addressof(message) : nullptr;
  }

  std::string* get_message() & {
    return __isset.message ? std::addressof(message) : nullptr;
  }
  std::string* get_message() && = delete;

  template <typename T_McFlushReReply_message_struct_setter>
  std::string& set_message(T_McFlushReReply_message_struct_setter&& message_) {
    message = std::forward<T_McFlushReReply_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  const int16_t* get_appSpecificErrorCode() const& {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }

  int16_t* get_appSpecificErrorCode() & {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }
  int16_t* get_appSpecificErrorCode() && = delete;

  int16_t& set_appSpecificErrorCode(int16_t appSpecificErrorCode_) {
    appSpecificErrorCode = appSpecificErrorCode_;
    __isset.appSpecificErrorCode = true;
    return appSpecificErrorCode;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McFlushReReply& a, McFlushReReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McFlushReReply>::clear( ::facebook::memcache::cpp2::McFlushReReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McFlushReReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McFlushReReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McFlushReReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McFlushReReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McFlushReReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McFlushReReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McFlushReReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McFlushReReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McFlushReReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McFlushAllRequest : private boost::totally_ordered<McFlushAllRequest> {
 public:

  McFlushAllRequest() :
      delay(0) {}
  // FragileConstructor for use in initialization lists only

  McFlushAllRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg, int32_t delay__arg) :
      key(std::move(key__arg)),
      delay(std::move(delay__arg)) {
    __isset.key = true;
    __isset.delay = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McFlushAllRequest(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McFlushAllRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    key = arg.move();
    __isset.key = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McFlushAllRequest(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McFlushAllRequest(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    delay = arg.move();
    __isset.delay = true;
  }

  McFlushAllRequest(McFlushAllRequest&&) = default;

  McFlushAllRequest(const McFlushAllRequest&) = default;

  McFlushAllRequest& operator=(McFlushAllRequest&&) = default;

  McFlushAllRequest& operator=(const McFlushAllRequest&) = default;
  void __clear();

  virtual ~McFlushAllRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;
  int32_t delay;

  struct __isset {
    void __clear() {
      key = false;
      delay = false;
    }

    bool key = false;
    bool delay = false;
  } __isset;
  bool operator==(const McFlushAllRequest& rhs) const;
  bool operator < (const McFlushAllRequest& rhs) const;

  const  ::facebook::memcache::cpp2::IOBuf& get_key() const& {
    return key;
  }

   ::facebook::memcache::cpp2::IOBuf get_key() && {
    return std::move(key);
  }

  template <typename T_McFlushAllRequest_key_struct_setter>
   ::facebook::memcache::cpp2::IOBuf& set_key(T_McFlushAllRequest_key_struct_setter&& key_) {
    key = std::forward<T_McFlushAllRequest_key_struct_setter>(key_);
    __isset.key = true;
    return key;
  }

  const int32_t* get_delay() const& {
    return __isset.delay ? std::addressof(delay) : nullptr;
  }

  int32_t* get_delay() & {
    return __isset.delay ? std::addressof(delay) : nullptr;
  }
  int32_t* get_delay() && = delete;

  int32_t& set_delay(int32_t delay_) {
    delay = delay_;
    __isset.delay = true;
    return delay;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McFlushAllRequest& a, McFlushAllRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McFlushAllRequest>::clear( ::facebook::memcache::cpp2::McFlushAllRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McFlushAllRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McFlushAllRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McFlushAllRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McFlushAllRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McFlushAllRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McFlushAllRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McFlushAllRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McFlushAllRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McFlushAllRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McFlushAllReply : private boost::totally_ordered<McFlushAllReply> {
 public:

  McFlushAllReply() :
      result(0),
      appSpecificErrorCode(0) {}
  // FragileConstructor for use in initialization lists only

  McFlushAllReply(apache::thrift::FragileConstructor, int16_t result__arg, std::string message__arg, int16_t appSpecificErrorCode__arg) :
      result(std::move(result__arg)),
      message(std::move(message__arg)),
      appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
    __isset.result = true;
    __isset.message = true;
    __isset.appSpecificErrorCode = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McFlushAllReply(::apache::thrift::detail::argument_wrapper<1, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McFlushAllReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    result = arg.move();
    __isset.result = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McFlushAllReply(::apache::thrift::detail::argument_wrapper<2, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McFlushAllReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    message = arg.move();
    __isset.message = true;
  }
  template <typename T__ThriftWrappedArgument__Ctor, typename... Args__ThriftWrappedArgument__Ctor>
  McFlushAllReply(::apache::thrift::detail::argument_wrapper<3, T__ThriftWrappedArgument__Ctor> arg, Args__ThriftWrappedArgument__Ctor&&... args):
    McFlushAllReply(std::forward<Args__ThriftWrappedArgument__Ctor>(args)...)
  {
    appSpecificErrorCode = arg.move();
    __isset.appSpecificErrorCode = true;
  }

  McFlushAllReply(McFlushAllReply&&) = default;

  McFlushAllReply(const McFlushAllReply&) = default;

  McFlushAllReply& operator=(McFlushAllReply&&) = default;

  McFlushAllReply& operator=(const McFlushAllReply&) = default;
  void __clear();

  virtual ~McFlushAllReply() throw() {}

  int16_t result;
  std::string message;
  int16_t appSpecificErrorCode;

  struct __isset {
    void __clear() {
      result = false;
      message = false;
      appSpecificErrorCode = false;
    }

    bool result = false;
    bool message = false;
    bool appSpecificErrorCode = false;
  } __isset;
  bool operator==(const McFlushAllReply& rhs) const;
  bool operator < (const McFlushAllReply& rhs) const;

  int16_t get_result() const {
    return result;
  }

  int16_t& set_result(int16_t result_) {
    result = result_;
    __isset.result = true;
    return result;
  }

  const std::string* get_message() const& {
    return __isset.message ? std::addressof(message) : nullptr;
  }

  std::string* get_message() & {
    return __isset.message ? std::addressof(message) : nullptr;
  }
  std::string* get_message() && = delete;

  template <typename T_McFlushAllReply_message_struct_setter>
  std::string& set_message(T_McFlushAllReply_message_struct_setter&& message_) {
    message = std::forward<T_McFlushAllReply_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  const int16_t* get_appSpecificErrorCode() const& {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }

  int16_t* get_appSpecificErrorCode() & {
    return __isset.appSpecificErrorCode ? std::addressof(appSpecificErrorCode) : nullptr;
  }
  int16_t* get_appSpecificErrorCode() && = delete;

  int16_t& set_appSpecificErrorCode(int16_t appSpecificErrorCode_) {
    appSpecificErrorCode = appSpecificErrorCode_;
    __isset.appSpecificErrorCode = true;
    return appSpecificErrorCode;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McFlushAllReply& a, McFlushAllReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McFlushAllReply>::clear( ::facebook::memcache::cpp2::McFlushAllReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McFlushAllReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McFlushAllReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McFlushAllReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McFlushAllReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McFlushAllReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McFlushAllReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McFlushAllReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McFlushAllReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McFlushAllReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

}}} // facebook::memcache::cpp2