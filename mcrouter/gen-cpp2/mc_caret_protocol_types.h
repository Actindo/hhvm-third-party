/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/Thrift.h>
#include <thrift/lib/cpp2/protocol/Protocol.h>
#include <thrift/lib/cpp/TApplicationException.h>
#include <folly/io/IOBuf.h>
#include <folly/io/Cursor.h>
#include <boost/operators.hpp>




namespace facebook { namespace memcache { namespace cpp2 {

class McGetRequest;
class McGetReply;
class McSetRequest;
class McSetReply;
class McDeleteRequest;
class McDeleteReply;
class McLeaseGetRequest;
class McLeaseGetReply;
class McLeaseSetRequest;
class McLeaseSetReply;
class McAddRequest;
class McAddReply;
class McReplaceRequest;
class McReplaceReply;
class McGetsRequest;
class McGetsReply;
class McCasRequest;
class McCasReply;
class McIncrRequest;
class McIncrReply;
class McDecrRequest;
class McDecrReply;
class McMetagetRequest;
class McMetagetReply;
class McVersionRequest;
class McVersionReply;
class McAppendRequest;
class McAppendReply;
class McPrependRequest;
class McPrependReply;
class McTouchRequest;
class McTouchReply;
typedef folly::IOBuf IOBuf;

class McGetRequest : private boost::totally_ordered<McGetRequest> {
 public:

  McGetRequest() {}
  // FragileConstructor for use in initialization lists only

  McGetRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg) :
      key(std::move(key__arg)) {}

  McGetRequest(McGetRequest&&) = default;

  McGetRequest(const McGetRequest&) = default;

  McGetRequest& operator=(McGetRequest&&) = default;

  McGetRequest& operator=(const McGetRequest&) = default;
  void __clear();

  virtual ~McGetRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      key = false;
    }

    bool key;
  } __isset;
  bool operator==(const McGetRequest& rhs) const;
  bool operator < (const McGetRequest& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McGetRequest& a, McGetRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McGetRequest>::clear( ::facebook::memcache::cpp2::McGetRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McGetRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McGetRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McGetRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McGetRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McGetRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McGetReply : private boost::totally_ordered<McGetReply> {
 public:

  McGetReply() :
      result(0),
      flags(0) {}
  // FragileConstructor for use in initialization lists only

  McGetReply(apache::thrift::FragileConstructor, int16_t result__arg,  ::facebook::memcache::cpp2::IOBuf value__arg, int64_t flags__arg,  ::facebook::memcache::cpp2::IOBuf message__arg) :
      result(std::move(result__arg)),
      value(std::move(value__arg)),
      flags(std::move(flags__arg)),
      message(std::move(message__arg)) {}

  McGetReply(McGetReply&&) = default;

  McGetReply(const McGetReply&) = default;

  McGetReply& operator=(McGetReply&&) = default;

  McGetReply& operator=(const McGetReply&) = default;
  void __clear();

  virtual ~McGetReply() throw() {}

  int16_t result;
   ::facebook::memcache::cpp2::IOBuf value;
  int64_t flags;
   ::facebook::memcache::cpp2::IOBuf message;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      result = false;
      value = false;
      flags = false;
      message = false;
    }

    bool result;
    bool value;
    bool flags;
    bool message;
  } __isset;
  bool operator==(const McGetReply& rhs) const;
  bool operator < (const McGetReply& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McGetReply& a, McGetReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McGetReply>::clear( ::facebook::memcache::cpp2::McGetReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McGetReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McGetReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McGetReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McGetReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McGetReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McSetRequest : private boost::totally_ordered<McSetRequest> {
 public:

  McSetRequest() :
      exptime(0),
      flags(0) {}
  // FragileConstructor for use in initialization lists only

  McSetRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg, int32_t exptime__arg, int64_t flags__arg,  ::facebook::memcache::cpp2::IOBuf value__arg) :
      key(std::move(key__arg)),
      exptime(std::move(exptime__arg)),
      flags(std::move(flags__arg)),
      value(std::move(value__arg)) {}

  McSetRequest(McSetRequest&&) = default;

  McSetRequest(const McSetRequest&) = default;

  McSetRequest& operator=(McSetRequest&&) = default;

  McSetRequest& operator=(const McSetRequest&) = default;
  void __clear();

  virtual ~McSetRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;
  int32_t exptime;
  int64_t flags;
   ::facebook::memcache::cpp2::IOBuf value;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      key = false;
      exptime = false;
      flags = false;
      value = false;
    }

    bool key;
    bool exptime;
    bool flags;
    bool value;
  } __isset;
  bool operator==(const McSetRequest& rhs) const;
  bool operator < (const McSetRequest& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McSetRequest& a, McSetRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McSetRequest>::clear( ::facebook::memcache::cpp2::McSetRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McSetRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McSetRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McSetRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McSetRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McSetRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McSetRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McSetRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McSetRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McSetRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McSetReply : private boost::totally_ordered<McSetReply> {
 public:

  McSetReply() :
      result(0) {}
  // FragileConstructor for use in initialization lists only

  McSetReply(apache::thrift::FragileConstructor, int16_t result__arg,  ::facebook::memcache::cpp2::IOBuf message__arg) :
      result(std::move(result__arg)),
      message(std::move(message__arg)) {}

  McSetReply(McSetReply&&) = default;

  McSetReply(const McSetReply&) = default;

  McSetReply& operator=(McSetReply&&) = default;

  McSetReply& operator=(const McSetReply&) = default;
  void __clear();

  virtual ~McSetReply() throw() {}

  int16_t result;
   ::facebook::memcache::cpp2::IOBuf message;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      result = false;
      message = false;
    }

    bool result;
    bool message;
  } __isset;
  bool operator==(const McSetReply& rhs) const;
  bool operator < (const McSetReply& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McSetReply& a, McSetReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McSetReply>::clear( ::facebook::memcache::cpp2::McSetReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McSetReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McSetReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McSetReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McSetReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McSetReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McSetReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McSetReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McSetReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McSetReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McDeleteRequest : private boost::totally_ordered<McDeleteRequest> {
 public:

  McDeleteRequest() :
      exptime(0) {}
  // FragileConstructor for use in initialization lists only

  McDeleteRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg, int32_t exptime__arg) :
      key(std::move(key__arg)),
      exptime(std::move(exptime__arg)) {}

  McDeleteRequest(McDeleteRequest&&) = default;

  McDeleteRequest(const McDeleteRequest&) = default;

  McDeleteRequest& operator=(McDeleteRequest&&) = default;

  McDeleteRequest& operator=(const McDeleteRequest&) = default;
  void __clear();

  virtual ~McDeleteRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;
  int32_t exptime;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      key = false;
      exptime = false;
    }

    bool key;
    bool exptime;
  } __isset;
  bool operator==(const McDeleteRequest& rhs) const;
  bool operator < (const McDeleteRequest& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McDeleteRequest& a, McDeleteRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McDeleteRequest>::clear( ::facebook::memcache::cpp2::McDeleteRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McDeleteRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDeleteRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McDeleteRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDeleteRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McDeleteRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDeleteRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McDeleteRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDeleteRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McDeleteRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McDeleteReply : private boost::totally_ordered<McDeleteReply> {
 public:

  McDeleteReply() :
      result(0) {}
  // FragileConstructor for use in initialization lists only

  McDeleteReply(apache::thrift::FragileConstructor, int16_t result__arg,  ::facebook::memcache::cpp2::IOBuf message__arg) :
      result(std::move(result__arg)),
      message(std::move(message__arg)) {}

  McDeleteReply(McDeleteReply&&) = default;

  McDeleteReply(const McDeleteReply&) = default;

  McDeleteReply& operator=(McDeleteReply&&) = default;

  McDeleteReply& operator=(const McDeleteReply&) = default;
  void __clear();

  virtual ~McDeleteReply() throw() {}

  int16_t result;
   ::facebook::memcache::cpp2::IOBuf message;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      result = false;
      message = false;
    }

    bool result;
    bool message;
  } __isset;
  bool operator==(const McDeleteReply& rhs) const;
  bool operator < (const McDeleteReply& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McDeleteReply& a, McDeleteReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McDeleteReply>::clear( ::facebook::memcache::cpp2::McDeleteReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McDeleteReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDeleteReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McDeleteReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDeleteReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McDeleteReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDeleteReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McDeleteReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDeleteReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McDeleteReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McLeaseGetRequest : private boost::totally_ordered<McLeaseGetRequest> {
 public:

  McLeaseGetRequest() {}
  // FragileConstructor for use in initialization lists only

  McLeaseGetRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg) :
      key(std::move(key__arg)) {}

  McLeaseGetRequest(McLeaseGetRequest&&) = default;

  McLeaseGetRequest(const McLeaseGetRequest&) = default;

  McLeaseGetRequest& operator=(McLeaseGetRequest&&) = default;

  McLeaseGetRequest& operator=(const McLeaseGetRequest&) = default;
  void __clear();

  virtual ~McLeaseGetRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      key = false;
    }

    bool key;
  } __isset;
  bool operator==(const McLeaseGetRequest& rhs) const;
  bool operator < (const McLeaseGetRequest& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McLeaseGetRequest& a, McLeaseGetRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McLeaseGetRequest>::clear( ::facebook::memcache::cpp2::McLeaseGetRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McLeaseGetRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseGetRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McLeaseGetRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseGetRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McLeaseGetRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseGetRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McLeaseGetRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseGetRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McLeaseGetRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McLeaseGetReply : private boost::totally_ordered<McLeaseGetReply> {
 public:

  McLeaseGetReply() :
      result(0),
      leaseToken(0),
      flags(0) {}
  // FragileConstructor for use in initialization lists only

  McLeaseGetReply(apache::thrift::FragileConstructor, int16_t result__arg, int64_t leaseToken__arg,  ::facebook::memcache::cpp2::IOBuf value__arg, int64_t flags__arg,  ::facebook::memcache::cpp2::IOBuf message__arg) :
      result(std::move(result__arg)),
      leaseToken(std::move(leaseToken__arg)),
      value(std::move(value__arg)),
      flags(std::move(flags__arg)),
      message(std::move(message__arg)) {}

  McLeaseGetReply(McLeaseGetReply&&) = default;

  McLeaseGetReply(const McLeaseGetReply&) = default;

  McLeaseGetReply& operator=(McLeaseGetReply&&) = default;

  McLeaseGetReply& operator=(const McLeaseGetReply&) = default;
  void __clear();

  virtual ~McLeaseGetReply() throw() {}

  int16_t result;
  int64_t leaseToken;
   ::facebook::memcache::cpp2::IOBuf value;
  int64_t flags;
   ::facebook::memcache::cpp2::IOBuf message;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      result = false;
      leaseToken = false;
      value = false;
      flags = false;
      message = false;
    }

    bool result;
    bool leaseToken;
    bool value;
    bool flags;
    bool message;
  } __isset;
  bool operator==(const McLeaseGetReply& rhs) const;
  bool operator < (const McLeaseGetReply& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McLeaseGetReply& a, McLeaseGetReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McLeaseGetReply>::clear( ::facebook::memcache::cpp2::McLeaseGetReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McLeaseGetReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseGetReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McLeaseGetReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseGetReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McLeaseGetReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseGetReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McLeaseGetReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseGetReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McLeaseGetReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McLeaseSetRequest : private boost::totally_ordered<McLeaseSetRequest> {
 public:

  McLeaseSetRequest() :
      exptime(0),
      flags(0),
      leaseToken(0) {}
  // FragileConstructor for use in initialization lists only

  McLeaseSetRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg, int32_t exptime__arg, int64_t flags__arg,  ::facebook::memcache::cpp2::IOBuf value__arg, int64_t leaseToken__arg) :
      key(std::move(key__arg)),
      exptime(std::move(exptime__arg)),
      flags(std::move(flags__arg)),
      value(std::move(value__arg)),
      leaseToken(std::move(leaseToken__arg)) {}

  McLeaseSetRequest(McLeaseSetRequest&&) = default;

  McLeaseSetRequest(const McLeaseSetRequest&) = default;

  McLeaseSetRequest& operator=(McLeaseSetRequest&&) = default;

  McLeaseSetRequest& operator=(const McLeaseSetRequest&) = default;
  void __clear();

  virtual ~McLeaseSetRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;
  int32_t exptime;
  int64_t flags;
   ::facebook::memcache::cpp2::IOBuf value;
  int64_t leaseToken;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      key = false;
      exptime = false;
      flags = false;
      value = false;
      leaseToken = false;
    }

    bool key;
    bool exptime;
    bool flags;
    bool value;
    bool leaseToken;
  } __isset;
  bool operator==(const McLeaseSetRequest& rhs) const;
  bool operator < (const McLeaseSetRequest& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McLeaseSetRequest& a, McLeaseSetRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McLeaseSetRequest>::clear( ::facebook::memcache::cpp2::McLeaseSetRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McLeaseSetRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseSetRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McLeaseSetRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseSetRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McLeaseSetRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseSetRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McLeaseSetRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseSetRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McLeaseSetRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McLeaseSetReply : private boost::totally_ordered<McLeaseSetReply> {
 public:

  McLeaseSetReply() :
      result(0) {}
  // FragileConstructor for use in initialization lists only

  McLeaseSetReply(apache::thrift::FragileConstructor, int16_t result__arg,  ::facebook::memcache::cpp2::IOBuf message__arg) :
      result(std::move(result__arg)),
      message(std::move(message__arg)) {}

  McLeaseSetReply(McLeaseSetReply&&) = default;

  McLeaseSetReply(const McLeaseSetReply&) = default;

  McLeaseSetReply& operator=(McLeaseSetReply&&) = default;

  McLeaseSetReply& operator=(const McLeaseSetReply&) = default;
  void __clear();

  virtual ~McLeaseSetReply() throw() {}

  int16_t result;
   ::facebook::memcache::cpp2::IOBuf message;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      result = false;
      message = false;
    }

    bool result;
    bool message;
  } __isset;
  bool operator==(const McLeaseSetReply& rhs) const;
  bool operator < (const McLeaseSetReply& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McLeaseSetReply& a, McLeaseSetReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McLeaseSetReply>::clear( ::facebook::memcache::cpp2::McLeaseSetReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McLeaseSetReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseSetReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McLeaseSetReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseSetReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McLeaseSetReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseSetReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McLeaseSetReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McLeaseSetReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McLeaseSetReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McAddRequest : private boost::totally_ordered<McAddRequest> {
 public:

  McAddRequest() :
      exptime(0),
      flags(0) {}
  // FragileConstructor for use in initialization lists only

  McAddRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg, int32_t exptime__arg, int64_t flags__arg,  ::facebook::memcache::cpp2::IOBuf value__arg) :
      key(std::move(key__arg)),
      exptime(std::move(exptime__arg)),
      flags(std::move(flags__arg)),
      value(std::move(value__arg)) {}

  McAddRequest(McAddRequest&&) = default;

  McAddRequest(const McAddRequest&) = default;

  McAddRequest& operator=(McAddRequest&&) = default;

  McAddRequest& operator=(const McAddRequest&) = default;
  void __clear();

  virtual ~McAddRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;
  int32_t exptime;
  int64_t flags;
   ::facebook::memcache::cpp2::IOBuf value;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      key = false;
      exptime = false;
      flags = false;
      value = false;
    }

    bool key;
    bool exptime;
    bool flags;
    bool value;
  } __isset;
  bool operator==(const McAddRequest& rhs) const;
  bool operator < (const McAddRequest& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McAddRequest& a, McAddRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McAddRequest>::clear( ::facebook::memcache::cpp2::McAddRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McAddRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAddRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McAddRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAddRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McAddRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAddRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McAddRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAddRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McAddRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McAddReply : private boost::totally_ordered<McAddReply> {
 public:

  McAddReply() :
      result(0) {}
  // FragileConstructor for use in initialization lists only

  McAddReply(apache::thrift::FragileConstructor, int16_t result__arg,  ::facebook::memcache::cpp2::IOBuf message__arg) :
      result(std::move(result__arg)),
      message(std::move(message__arg)) {}

  McAddReply(McAddReply&&) = default;

  McAddReply(const McAddReply&) = default;

  McAddReply& operator=(McAddReply&&) = default;

  McAddReply& operator=(const McAddReply&) = default;
  void __clear();

  virtual ~McAddReply() throw() {}

  int16_t result;
   ::facebook::memcache::cpp2::IOBuf message;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      result = false;
      message = false;
    }

    bool result;
    bool message;
  } __isset;
  bool operator==(const McAddReply& rhs) const;
  bool operator < (const McAddReply& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McAddReply& a, McAddReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McAddReply>::clear( ::facebook::memcache::cpp2::McAddReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McAddReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAddReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McAddReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAddReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McAddReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAddReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McAddReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAddReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McAddReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McReplaceRequest : private boost::totally_ordered<McReplaceRequest> {
 public:

  McReplaceRequest() :
      exptime(0),
      flags(0) {}
  // FragileConstructor for use in initialization lists only

  McReplaceRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg, int32_t exptime__arg, int64_t flags__arg,  ::facebook::memcache::cpp2::IOBuf value__arg) :
      key(std::move(key__arg)),
      exptime(std::move(exptime__arg)),
      flags(std::move(flags__arg)),
      value(std::move(value__arg)) {}

  McReplaceRequest(McReplaceRequest&&) = default;

  McReplaceRequest(const McReplaceRequest&) = default;

  McReplaceRequest& operator=(McReplaceRequest&&) = default;

  McReplaceRequest& operator=(const McReplaceRequest&) = default;
  void __clear();

  virtual ~McReplaceRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;
  int32_t exptime;
  int64_t flags;
   ::facebook::memcache::cpp2::IOBuf value;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      key = false;
      exptime = false;
      flags = false;
      value = false;
    }

    bool key;
    bool exptime;
    bool flags;
    bool value;
  } __isset;
  bool operator==(const McReplaceRequest& rhs) const;
  bool operator < (const McReplaceRequest& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McReplaceRequest& a, McReplaceRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McReplaceRequest>::clear( ::facebook::memcache::cpp2::McReplaceRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McReplaceRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McReplaceRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McReplaceRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McReplaceRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McReplaceRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McReplaceRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McReplaceRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McReplaceRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McReplaceRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McReplaceReply : private boost::totally_ordered<McReplaceReply> {
 public:

  McReplaceReply() :
      result(0) {}
  // FragileConstructor for use in initialization lists only

  McReplaceReply(apache::thrift::FragileConstructor, int16_t result__arg,  ::facebook::memcache::cpp2::IOBuf message__arg) :
      result(std::move(result__arg)),
      message(std::move(message__arg)) {}

  McReplaceReply(McReplaceReply&&) = default;

  McReplaceReply(const McReplaceReply&) = default;

  McReplaceReply& operator=(McReplaceReply&&) = default;

  McReplaceReply& operator=(const McReplaceReply&) = default;
  void __clear();

  virtual ~McReplaceReply() throw() {}

  int16_t result;
   ::facebook::memcache::cpp2::IOBuf message;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      result = false;
      message = false;
    }

    bool result;
    bool message;
  } __isset;
  bool operator==(const McReplaceReply& rhs) const;
  bool operator < (const McReplaceReply& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McReplaceReply& a, McReplaceReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McReplaceReply>::clear( ::facebook::memcache::cpp2::McReplaceReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McReplaceReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McReplaceReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McReplaceReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McReplaceReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McReplaceReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McReplaceReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McReplaceReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McReplaceReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McReplaceReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McGetsRequest : private boost::totally_ordered<McGetsRequest> {
 public:

  McGetsRequest() {}
  // FragileConstructor for use in initialization lists only

  McGetsRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg) :
      key(std::move(key__arg)) {}

  McGetsRequest(McGetsRequest&&) = default;

  McGetsRequest(const McGetsRequest&) = default;

  McGetsRequest& operator=(McGetsRequest&&) = default;

  McGetsRequest& operator=(const McGetsRequest&) = default;
  void __clear();

  virtual ~McGetsRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      key = false;
    }

    bool key;
  } __isset;
  bool operator==(const McGetsRequest& rhs) const;
  bool operator < (const McGetsRequest& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McGetsRequest& a, McGetsRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McGetsRequest>::clear( ::facebook::memcache::cpp2::McGetsRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McGetsRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetsRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McGetsRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetsRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McGetsRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetsRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McGetsRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetsRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McGetsRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McGetsReply : private boost::totally_ordered<McGetsReply> {
 public:

  McGetsReply() :
      result(0),
      casToken(0),
      flags(0) {}
  // FragileConstructor for use in initialization lists only

  McGetsReply(apache::thrift::FragileConstructor, int16_t result__arg, int64_t casToken__arg,  ::facebook::memcache::cpp2::IOBuf value__arg, int64_t flags__arg,  ::facebook::memcache::cpp2::IOBuf message__arg) :
      result(std::move(result__arg)),
      casToken(std::move(casToken__arg)),
      value(std::move(value__arg)),
      flags(std::move(flags__arg)),
      message(std::move(message__arg)) {}

  McGetsReply(McGetsReply&&) = default;

  McGetsReply(const McGetsReply&) = default;

  McGetsReply& operator=(McGetsReply&&) = default;

  McGetsReply& operator=(const McGetsReply&) = default;
  void __clear();

  virtual ~McGetsReply() throw() {}

  int16_t result;
  int64_t casToken;
   ::facebook::memcache::cpp2::IOBuf value;
  int64_t flags;
   ::facebook::memcache::cpp2::IOBuf message;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      result = false;
      casToken = false;
      value = false;
      flags = false;
      message = false;
    }

    bool result;
    bool casToken;
    bool value;
    bool flags;
    bool message;
  } __isset;
  bool operator==(const McGetsReply& rhs) const;
  bool operator < (const McGetsReply& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McGetsReply& a, McGetsReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McGetsReply>::clear( ::facebook::memcache::cpp2::McGetsReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McGetsReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetsReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McGetsReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetsReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McGetsReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetsReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McGetsReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McGetsReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McGetsReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McCasRequest : private boost::totally_ordered<McCasRequest> {
 public:

  McCasRequest() :
      exptime(0),
      flags(0),
      casToken(0) {}
  // FragileConstructor for use in initialization lists only

  McCasRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg, int32_t exptime__arg, int64_t flags__arg,  ::facebook::memcache::cpp2::IOBuf value__arg, int64_t casToken__arg) :
      key(std::move(key__arg)),
      exptime(std::move(exptime__arg)),
      flags(std::move(flags__arg)),
      value(std::move(value__arg)),
      casToken(std::move(casToken__arg)) {}

  McCasRequest(McCasRequest&&) = default;

  McCasRequest(const McCasRequest&) = default;

  McCasRequest& operator=(McCasRequest&&) = default;

  McCasRequest& operator=(const McCasRequest&) = default;
  void __clear();

  virtual ~McCasRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;
  int32_t exptime;
  int64_t flags;
   ::facebook::memcache::cpp2::IOBuf value;
  int64_t casToken;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      key = false;
      exptime = false;
      flags = false;
      value = false;
      casToken = false;
    }

    bool key;
    bool exptime;
    bool flags;
    bool value;
    bool casToken;
  } __isset;
  bool operator==(const McCasRequest& rhs) const;
  bool operator < (const McCasRequest& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McCasRequest& a, McCasRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McCasRequest>::clear( ::facebook::memcache::cpp2::McCasRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McCasRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McCasRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McCasRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McCasRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McCasRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McCasRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McCasRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McCasRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McCasRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McCasReply : private boost::totally_ordered<McCasReply> {
 public:

  McCasReply() :
      result(0) {}
  // FragileConstructor for use in initialization lists only

  McCasReply(apache::thrift::FragileConstructor, int16_t result__arg,  ::facebook::memcache::cpp2::IOBuf message__arg) :
      result(std::move(result__arg)),
      message(std::move(message__arg)) {}

  McCasReply(McCasReply&&) = default;

  McCasReply(const McCasReply&) = default;

  McCasReply& operator=(McCasReply&&) = default;

  McCasReply& operator=(const McCasReply&) = default;
  void __clear();

  virtual ~McCasReply() throw() {}

  int16_t result;
   ::facebook::memcache::cpp2::IOBuf message;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      result = false;
      message = false;
    }

    bool result;
    bool message;
  } __isset;
  bool operator==(const McCasReply& rhs) const;
  bool operator < (const McCasReply& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McCasReply& a, McCasReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McCasReply>::clear( ::facebook::memcache::cpp2::McCasReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McCasReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McCasReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McCasReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McCasReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McCasReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McCasReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McCasReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McCasReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McCasReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McIncrRequest : private boost::totally_ordered<McIncrRequest> {
 public:

  McIncrRequest() :
      delta(0) {}
  // FragileConstructor for use in initialization lists only

  McIncrRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg, int64_t delta__arg) :
      key(std::move(key__arg)),
      delta(std::move(delta__arg)) {}

  McIncrRequest(McIncrRequest&&) = default;

  McIncrRequest(const McIncrRequest&) = default;

  McIncrRequest& operator=(McIncrRequest&&) = default;

  McIncrRequest& operator=(const McIncrRequest&) = default;
  void __clear();

  virtual ~McIncrRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;
  int64_t delta;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      key = false;
      delta = false;
    }

    bool key;
    bool delta;
  } __isset;
  bool operator==(const McIncrRequest& rhs) const;
  bool operator < (const McIncrRequest& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McIncrRequest& a, McIncrRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McIncrRequest>::clear( ::facebook::memcache::cpp2::McIncrRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McIncrRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McIncrRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McIncrRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McIncrRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McIncrRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McIncrRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McIncrRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McIncrRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McIncrRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McIncrReply : private boost::totally_ordered<McIncrReply> {
 public:

  McIncrReply() :
      result(0),
      delta(0) {}
  // FragileConstructor for use in initialization lists only

  McIncrReply(apache::thrift::FragileConstructor, int16_t result__arg, int64_t delta__arg,  ::facebook::memcache::cpp2::IOBuf message__arg) :
      result(std::move(result__arg)),
      delta(std::move(delta__arg)),
      message(std::move(message__arg)) {}

  McIncrReply(McIncrReply&&) = default;

  McIncrReply(const McIncrReply&) = default;

  McIncrReply& operator=(McIncrReply&&) = default;

  McIncrReply& operator=(const McIncrReply&) = default;
  void __clear();

  virtual ~McIncrReply() throw() {}

  int16_t result;
  int64_t delta;
   ::facebook::memcache::cpp2::IOBuf message;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      result = false;
      delta = false;
      message = false;
    }

    bool result;
    bool delta;
    bool message;
  } __isset;
  bool operator==(const McIncrReply& rhs) const;
  bool operator < (const McIncrReply& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McIncrReply& a, McIncrReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McIncrReply>::clear( ::facebook::memcache::cpp2::McIncrReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McIncrReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McIncrReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McIncrReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McIncrReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McIncrReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McIncrReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McIncrReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McIncrReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McIncrReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McDecrRequest : private boost::totally_ordered<McDecrRequest> {
 public:

  McDecrRequest() :
      delta(0) {}
  // FragileConstructor for use in initialization lists only

  McDecrRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg, int64_t delta__arg) :
      key(std::move(key__arg)),
      delta(std::move(delta__arg)) {}

  McDecrRequest(McDecrRequest&&) = default;

  McDecrRequest(const McDecrRequest&) = default;

  McDecrRequest& operator=(McDecrRequest&&) = default;

  McDecrRequest& operator=(const McDecrRequest&) = default;
  void __clear();

  virtual ~McDecrRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;
  int64_t delta;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      key = false;
      delta = false;
    }

    bool key;
    bool delta;
  } __isset;
  bool operator==(const McDecrRequest& rhs) const;
  bool operator < (const McDecrRequest& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McDecrRequest& a, McDecrRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McDecrRequest>::clear( ::facebook::memcache::cpp2::McDecrRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McDecrRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDecrRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McDecrRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDecrRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McDecrRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDecrRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McDecrRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDecrRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McDecrRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McDecrReply : private boost::totally_ordered<McDecrReply> {
 public:

  McDecrReply() :
      result(0),
      delta(0) {}
  // FragileConstructor for use in initialization lists only

  McDecrReply(apache::thrift::FragileConstructor, int16_t result__arg, int64_t delta__arg,  ::facebook::memcache::cpp2::IOBuf message__arg) :
      result(std::move(result__arg)),
      delta(std::move(delta__arg)),
      message(std::move(message__arg)) {}

  McDecrReply(McDecrReply&&) = default;

  McDecrReply(const McDecrReply&) = default;

  McDecrReply& operator=(McDecrReply&&) = default;

  McDecrReply& operator=(const McDecrReply&) = default;
  void __clear();

  virtual ~McDecrReply() throw() {}

  int16_t result;
  int64_t delta;
   ::facebook::memcache::cpp2::IOBuf message;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      result = false;
      delta = false;
      message = false;
    }

    bool result;
    bool delta;
    bool message;
  } __isset;
  bool operator==(const McDecrReply& rhs) const;
  bool operator < (const McDecrReply& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McDecrReply& a, McDecrReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McDecrReply>::clear( ::facebook::memcache::cpp2::McDecrReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McDecrReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDecrReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McDecrReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDecrReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McDecrReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDecrReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McDecrReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McDecrReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McDecrReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McMetagetRequest : private boost::totally_ordered<McMetagetRequest> {
 public:

  McMetagetRequest() {}
  // FragileConstructor for use in initialization lists only

  McMetagetRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg) :
      key(std::move(key__arg)) {}

  McMetagetRequest(McMetagetRequest&&) = default;

  McMetagetRequest(const McMetagetRequest&) = default;

  McMetagetRequest& operator=(McMetagetRequest&&) = default;

  McMetagetRequest& operator=(const McMetagetRequest&) = default;
  void __clear();

  virtual ~McMetagetRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      key = false;
    }

    bool key;
  } __isset;
  bool operator==(const McMetagetRequest& rhs) const;
  bool operator < (const McMetagetRequest& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McMetagetRequest& a, McMetagetRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McMetagetRequest>::clear( ::facebook::memcache::cpp2::McMetagetRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McMetagetRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McMetagetRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McMetagetRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McMetagetRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McMetagetRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McMetagetRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McMetagetRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McMetagetRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McMetagetRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McMetagetReply : private boost::totally_ordered<McMetagetReply> {
 public:

  McMetagetReply() :
      result(0),
      age(0),
      exptime(0),
      isTransient(0),
      ipv(0) {}
  // FragileConstructor for use in initialization lists only

  McMetagetReply(apache::thrift::FragileConstructor, int16_t result__arg, int32_t age__arg, int32_t exptime__arg, bool isTransient__arg, int16_t ipv__arg, std::string ipAddress__arg,  ::facebook::memcache::cpp2::IOBuf message__arg) :
      result(std::move(result__arg)),
      age(std::move(age__arg)),
      exptime(std::move(exptime__arg)),
      isTransient(std::move(isTransient__arg)),
      ipv(std::move(ipv__arg)),
      ipAddress(std::move(ipAddress__arg)),
      message(std::move(message__arg)) {}

  McMetagetReply(McMetagetReply&&) = default;

  McMetagetReply(const McMetagetReply&) = default;

  McMetagetReply& operator=(McMetagetReply&&) = default;

  McMetagetReply& operator=(const McMetagetReply&) = default;
  void __clear();

  virtual ~McMetagetReply() throw() {}

  int16_t result;
  int32_t age;
  int32_t exptime;
  bool isTransient;
  int16_t ipv;
  std::string ipAddress;
   ::facebook::memcache::cpp2::IOBuf message;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      result = false;
      age = false;
      exptime = false;
      isTransient = false;
      ipv = false;
      ipAddress = false;
      message = false;
    }

    bool result;
    bool age;
    bool exptime;
    bool isTransient;
    bool ipv;
    bool ipAddress;
    bool message;
  } __isset;
  bool operator==(const McMetagetReply& rhs) const;
  bool operator < (const McMetagetReply& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McMetagetReply& a, McMetagetReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McMetagetReply>::clear( ::facebook::memcache::cpp2::McMetagetReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McMetagetReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McMetagetReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McMetagetReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McMetagetReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McMetagetReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McMetagetReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McMetagetReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McMetagetReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McMetagetReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McVersionRequest : private boost::totally_ordered<McVersionRequest> {
 public:

  McVersionRequest() {}
  // FragileConstructor for use in initialization lists only

  McVersionRequest(apache::thrift::FragileConstructor) {}

  McVersionRequest(McVersionRequest&&) = default;

  McVersionRequest(const McVersionRequest&) = default;

  McVersionRequest& operator=(McVersionRequest&&) = default;

  McVersionRequest& operator=(const McVersionRequest&) = default;

  virtual ~McVersionRequest() throw() {}

  bool operator==(const McVersionRequest& /* rhs */) const;

  bool operator < (const McVersionRequest& rhs) const {
    return false;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McVersionRequest& a, McVersionRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McVersionRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McVersionRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McVersionRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McVersionRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McVersionRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McVersionRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McVersionRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McVersionRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McVersionRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McVersionReply : private boost::totally_ordered<McVersionReply> {
 public:

  McVersionReply() :
      result(0) {}
  // FragileConstructor for use in initialization lists only

  McVersionReply(apache::thrift::FragileConstructor, int16_t result__arg, std::string version__arg,  ::facebook::memcache::cpp2::IOBuf message__arg) :
      result(std::move(result__arg)),
      version(std::move(version__arg)),
      message(std::move(message__arg)) {}

  McVersionReply(McVersionReply&&) = default;

  McVersionReply(const McVersionReply&) = default;

  McVersionReply& operator=(McVersionReply&&) = default;

  McVersionReply& operator=(const McVersionReply&) = default;
  void __clear();

  virtual ~McVersionReply() throw() {}

  int16_t result;
  std::string version;
   ::facebook::memcache::cpp2::IOBuf message;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      result = false;
      version = false;
      message = false;
    }

    bool result;
    bool version;
    bool message;
  } __isset;
  bool operator==(const McVersionReply& rhs) const;
  bool operator < (const McVersionReply& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McVersionReply& a, McVersionReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McVersionReply>::clear( ::facebook::memcache::cpp2::McVersionReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McVersionReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McVersionReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McVersionReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McVersionReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McVersionReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McVersionReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McVersionReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McVersionReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McVersionReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McAppendRequest : private boost::totally_ordered<McAppendRequest> {
 public:

  McAppendRequest() :
      exptime(0),
      flags(0) {}
  // FragileConstructor for use in initialization lists only

  McAppendRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg, int32_t exptime__arg, int64_t flags__arg,  ::facebook::memcache::cpp2::IOBuf value__arg) :
      key(std::move(key__arg)),
      exptime(std::move(exptime__arg)),
      flags(std::move(flags__arg)),
      value(std::move(value__arg)) {}

  McAppendRequest(McAppendRequest&&) = default;

  McAppendRequest(const McAppendRequest&) = default;

  McAppendRequest& operator=(McAppendRequest&&) = default;

  McAppendRequest& operator=(const McAppendRequest&) = default;
  void __clear();

  virtual ~McAppendRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;
  int32_t exptime;
  int64_t flags;
   ::facebook::memcache::cpp2::IOBuf value;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      key = false;
      exptime = false;
      flags = false;
      value = false;
    }

    bool key;
    bool exptime;
    bool flags;
    bool value;
  } __isset;
  bool operator==(const McAppendRequest& rhs) const;
  bool operator < (const McAppendRequest& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McAppendRequest& a, McAppendRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McAppendRequest>::clear( ::facebook::memcache::cpp2::McAppendRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McAppendRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAppendRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McAppendRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAppendRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McAppendRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAppendRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McAppendRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAppendRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McAppendRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McAppendReply : private boost::totally_ordered<McAppendReply> {
 public:

  McAppendReply() :
      result(0) {}
  // FragileConstructor for use in initialization lists only

  McAppendReply(apache::thrift::FragileConstructor, int16_t result__arg,  ::facebook::memcache::cpp2::IOBuf message__arg) :
      result(std::move(result__arg)),
      message(std::move(message__arg)) {}

  McAppendReply(McAppendReply&&) = default;

  McAppendReply(const McAppendReply&) = default;

  McAppendReply& operator=(McAppendReply&&) = default;

  McAppendReply& operator=(const McAppendReply&) = default;
  void __clear();

  virtual ~McAppendReply() throw() {}

  int16_t result;
   ::facebook::memcache::cpp2::IOBuf message;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      result = false;
      message = false;
    }

    bool result;
    bool message;
  } __isset;
  bool operator==(const McAppendReply& rhs) const;
  bool operator < (const McAppendReply& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McAppendReply& a, McAppendReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McAppendReply>::clear( ::facebook::memcache::cpp2::McAppendReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McAppendReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAppendReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McAppendReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAppendReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McAppendReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAppendReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McAppendReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McAppendReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McAppendReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McPrependRequest : private boost::totally_ordered<McPrependRequest> {
 public:

  McPrependRequest() :
      exptime(0),
      flags(0) {}
  // FragileConstructor for use in initialization lists only

  McPrependRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg, int32_t exptime__arg, int64_t flags__arg,  ::facebook::memcache::cpp2::IOBuf value__arg) :
      key(std::move(key__arg)),
      exptime(std::move(exptime__arg)),
      flags(std::move(flags__arg)),
      value(std::move(value__arg)) {}

  McPrependRequest(McPrependRequest&&) = default;

  McPrependRequest(const McPrependRequest&) = default;

  McPrependRequest& operator=(McPrependRequest&&) = default;

  McPrependRequest& operator=(const McPrependRequest&) = default;
  void __clear();

  virtual ~McPrependRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;
  int32_t exptime;
  int64_t flags;
   ::facebook::memcache::cpp2::IOBuf value;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      key = false;
      exptime = false;
      flags = false;
      value = false;
    }

    bool key;
    bool exptime;
    bool flags;
    bool value;
  } __isset;
  bool operator==(const McPrependRequest& rhs) const;
  bool operator < (const McPrependRequest& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McPrependRequest& a, McPrependRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McPrependRequest>::clear( ::facebook::memcache::cpp2::McPrependRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McPrependRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McPrependRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McPrependRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McPrependRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McPrependRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McPrependRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McPrependRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McPrependRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McPrependRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McPrependReply : private boost::totally_ordered<McPrependReply> {
 public:

  McPrependReply() :
      result(0) {}
  // FragileConstructor for use in initialization lists only

  McPrependReply(apache::thrift::FragileConstructor, int16_t result__arg,  ::facebook::memcache::cpp2::IOBuf message__arg) :
      result(std::move(result__arg)),
      message(std::move(message__arg)) {}

  McPrependReply(McPrependReply&&) = default;

  McPrependReply(const McPrependReply&) = default;

  McPrependReply& operator=(McPrependReply&&) = default;

  McPrependReply& operator=(const McPrependReply&) = default;
  void __clear();

  virtual ~McPrependReply() throw() {}

  int16_t result;
   ::facebook::memcache::cpp2::IOBuf message;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      result = false;
      message = false;
    }

    bool result;
    bool message;
  } __isset;
  bool operator==(const McPrependReply& rhs) const;
  bool operator < (const McPrependReply& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McPrependReply& a, McPrependReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McPrependReply>::clear( ::facebook::memcache::cpp2::McPrependReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McPrependReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McPrependReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McPrependReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McPrependReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McPrependReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McPrependReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McPrependReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McPrependReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McPrependReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McTouchRequest : private boost::totally_ordered<McTouchRequest> {
 public:

  McTouchRequest() :
      exptime(0) {}
  // FragileConstructor for use in initialization lists only

  McTouchRequest(apache::thrift::FragileConstructor,  ::facebook::memcache::cpp2::IOBuf key__arg, int32_t exptime__arg) :
      key(std::move(key__arg)),
      exptime(std::move(exptime__arg)) {}

  McTouchRequest(McTouchRequest&&) = default;

  McTouchRequest(const McTouchRequest&) = default;

  McTouchRequest& operator=(McTouchRequest&&) = default;

  McTouchRequest& operator=(const McTouchRequest&) = default;
  void __clear();

  virtual ~McTouchRequest() throw() {}

   ::facebook::memcache::cpp2::IOBuf key;
  int32_t exptime;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      key = false;
      exptime = false;
    }

    bool key;
    bool exptime;
  } __isset;
  bool operator==(const McTouchRequest& rhs) const;
  bool operator < (const McTouchRequest& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McTouchRequest& a, McTouchRequest& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McTouchRequest>::clear( ::facebook::memcache::cpp2::McTouchRequest* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McTouchRequest>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McTouchRequest>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McTouchRequest* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McTouchRequest>::read(Protocol* proto,   ::facebook::memcache::cpp2::McTouchRequest* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McTouchRequest>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McTouchRequest* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McTouchRequest>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McTouchRequest* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

class McTouchReply : private boost::totally_ordered<McTouchReply> {
 public:

  McTouchReply() :
      result(0) {}
  // FragileConstructor for use in initialization lists only

  McTouchReply(apache::thrift::FragileConstructor, int16_t result__arg,  ::facebook::memcache::cpp2::IOBuf message__arg) :
      result(std::move(result__arg)),
      message(std::move(message__arg)) {}

  McTouchReply(McTouchReply&&) = default;

  McTouchReply(const McTouchReply&) = default;

  McTouchReply& operator=(McTouchReply&&) = default;

  McTouchReply& operator=(const McTouchReply&) = default;
  void __clear();

  virtual ~McTouchReply() throw() {}

  int16_t result;
   ::facebook::memcache::cpp2::IOBuf message;

  struct __isset {
    __isset() {
      __clear();
    }

    void __clear() {
      result = false;
      message = false;
    }

    bool result;
    bool message;
  } __isset;
  bool operator==(const McTouchReply& rhs) const;
  bool operator < (const McTouchReply& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
};

void swap(McTouchReply& a, McTouchReply& b);

}}} // facebook::memcache::cpp2
namespace apache { namespace thrift {

template <> inline void Cpp2Ops< ::facebook::memcache::cpp2::McTouchReply>::clear( ::facebook::memcache::cpp2::McTouchReply* obj) {
  return obj->__clear();
}

template <> inline constexpr apache::thrift::protocol::TType Cpp2Ops< ::facebook::memcache::cpp2::McTouchReply>::thriftType() {
  return apache::thrift::protocol::T_STRUCT;
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McTouchReply>::write(Protocol* proto, const  ::facebook::memcache::cpp2::McTouchReply* obj) {
  return obj->write(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McTouchReply>::read(Protocol* proto,   ::facebook::memcache::cpp2::McTouchReply* obj) {
  return obj->read(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McTouchReply>::serializedSize(Protocol* proto, const  ::facebook::memcache::cpp2::McTouchReply* obj) {
  return obj->serializedSize(proto);
}

template <> template <class Protocol> inline uint32_t Cpp2Ops< ::facebook::memcache::cpp2::McTouchReply>::serializedSizeZC(Protocol* proto, const  ::facebook::memcache::cpp2::McTouchReply* obj) {
  return obj->serializedSizeZC(proto);
}

}} // apache::thrift
namespace facebook { namespace memcache { namespace cpp2 {

}}} // facebook::memcache::cpp2